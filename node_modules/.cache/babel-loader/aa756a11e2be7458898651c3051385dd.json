{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.createUserProfile = exports.createUser = exports.confirmPasswordReset = exports.applyActionCode = void 0, exports.handleProfileWatchResponse = handleProfileWatchResponse, exports.init = exports.handleRedirectResult = void 0, exports.linkAndRetrieveDataWithCredential = linkAndRetrieveDataWithCredential, exports.linkWithCredential = void 0, exports.linkWithPopup = linkWithPopup, exports.linkWithRedirect = linkWithRedirect, exports.resetPassword = exports.reloadAuth = exports.reauthenticate = exports.logout = exports.login = void 0, exports.signInWithPhoneNumber = signInWithPhoneNumber, exports.unWatchUserProfile = unWatchUserProfile, exports.watchUserProfile = exports.verifyPasswordResetCode = exports.updateProfile = exports.updateEmail = exports.updateAuth = void 0;\nvar _pick2 = _interopRequireDefault(require(\"lodash/pick\")),\n  _omit2 = _interopRequireDefault(require(\"lodash/omit\")),\n  _forEach2 = _interopRequireDefault(require(\"lodash/forEach\")),\n  _constants = require(\"../constants\"),\n  _helpers = require(\"../helpers\"),\n  _utils = require(\"../utils\"),\n  _auth = require(\"../utils/auth\"),\n  _populate = require(\"../utils/populate\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (o) {\n    if (\"string\" == typeof o) return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    return \"Object\" === n && o.constructor && (n = o.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(o) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;\n  }\n}\nfunction _iterableToArray(iter) {\n  if (\"undefined\" != typeof Symbol && null != iter[Symbol.iterator] || null != iter[\"@@iterator\"]) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  (null == len || len > arr.length) && (len = arr.length);\n  for (var i = 0, arr2 = Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\nfunction dispatchLoginError(dispatch, authError) {\n  var params = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {};\n  return dispatch(_objectSpread(_objectSpread({\n    type: _constants.actionTypes.LOGIN_ERROR\n  }, params), {}, {\n    authError: authError\n  }));\n}\nfunction unWatchUserProfile(firebase) {\n  var _firebase$_ = firebase._,\n    authUid = _firebase$_.authUid,\n    _firebase$_$config = _firebase$_.config,\n    userProfile = _firebase$_$config.userProfile,\n    useFirestoreForProfile = _firebase$_$config.useFirestoreForProfile;\n  firebase._.profileWatch && (useFirestoreForProfile && firebase.firestore ? firebase._.profileWatch() : userProfile && firebase.database && firebase.database().ref().child(\"\".concat(userProfile, \"/\").concat(authUid)).off(\"value\", firebase._.profileWatch), firebase._.profileWatch = null);\n}\nfunction getProfileFromSnap(snap) {\n  return snap && snap.val ? snap.val() : snap && snap.data && snap.exists ? snap.data() : null;\n}\nfunction handleProfileWatchResponse(dispatch, firebase, userProfileSnap, token) {\n  var _firebase$_$config2 = firebase._.config,\n    profileParamsToPopulate = _firebase$_$config2.profileParamsToPopulate,\n    autoPopulateProfile = _firebase$_$config2.autoPopulateProfile,\n    useFirestoreForProfile = _firebase$_$config2.useFirestoreForProfile,\n    logErrors = _firebase$_$config2.logErrors,\n    profile = getProfileFromSnap(userProfileSnap);\n  profileParamsToPopulate && !useFirestoreForProfile && (Array.isArray(profileParamsToPopulate) || (0, _utils.isString)(profileParamsToPopulate)) ? (0, _populate.promisesForPopulate)(firebase, userProfileSnap.key, profile, profileParamsToPopulate).then(function (data) {\n    if ((0, _forEach2.default)(data, function (result, path) {\n      dispatch({\n        type: _constants.actionTypes.SET,\n        path: path,\n        data: result,\n        timestamp: Date.now(),\n        requesting: !1,\n        requested: !0\n      });\n    }), !autoPopulateProfile) dispatch({\n      type: _constants.actionTypes.SET_PROFILE,\n      profile: token ? _objectSpread(_objectSpread({}, profile), {}, {\n        token: token\n      }) : profile\n    });else {\n      var populates = (0, _populate.getPopulateObjs)(profileParamsToPopulate),\n        _profile = userProfileSnap.val();\n      dispatch({\n        type: _constants.actionTypes.SET_PROFILE,\n        profile: (0, _helpers.populate)({\n          profile: token ? _objectSpread(_objectSpread({}, _profile), {}, {\n            token: token\n          }) : _profile,\n          data: data\n        }, \"profile\", populates)\n      });\n    }\n  }).catch(function (err) {\n    logErrors && console.error(\"RRF: Error retrieving data for profile population. Firebase:\", err), dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      authError: \"Error during profile population: \".concat(err.message)\n    }), dispatch({\n      type: _constants.actionTypes.SET_PROFILE,\n      profile: profile\n    });\n  }) : (useFirestoreForProfile && profileParamsToPopulate && console.warn(\"Profile population is not yet supported for Firestore\"), dispatch({\n    type: _constants.actionTypes.SET_PROFILE,\n    profile: token ? _objectSpread(_objectSpread({}, profile), {}, {\n      token: token\n    }) : profile\n  }));\n}\nfunction createProfileWatchErrorHandler(dispatch, firebase) {\n  var _firebase$_$config3 = firebase._.config,\n    onProfileListenerError = _firebase$_$config3.onProfileListenerError,\n    logErrors = _firebase$_$config3.logErrors;\n  return function (err) {\n    if (logErrors && console.error(\"Error with profile listener: \".concat(err.message || \"\"), err), \"function\" == typeof onProfileListenerError) {\n      var factoryResult = onProfileListenerError(err, firebase);\n      if (\"function\" == typeof factoryResult.then) return factoryResult;\n    }\n    return Promise.reject(err);\n  };\n}\nvar watchUserProfile = function (dispatch, firebase) {\n  var _firebase$_2 = firebase._,\n    authUid = _firebase$_2.authUid,\n    _firebase$_2$config = _firebase$_2.config,\n    userProfile = _firebase$_2$config.userProfile,\n    useFirestoreForProfile = _firebase$_2$config.useFirestoreForProfile,\n    enableClaims = _firebase$_2$config.enableClaims;\n  if (unWatchUserProfile(firebase), !userProfile) enableClaims && (firebase._.profileWatch = firebase.auth().currentUser.getIdTokenResult(!0).then(function (token) {\n    dispatch({\n      type: _constants.actionTypes.SET_PROFILE,\n      profile: {\n        token: token\n      }\n    });\n  }));else if (useFirestoreForProfile && firebase.firestore) firebase._.profileWatch = firebase.firestore().collection(userProfile).doc(authUid).onSnapshot(function (userProfileSnap) {\n    return enableClaims ? firebase.auth().currentUser.getIdTokenResult(!0).then(function (token) {\n      return handleProfileWatchResponse(dispatch, firebase, userProfileSnap, token);\n    }) : handleProfileWatchResponse(dispatch, firebase, userProfileSnap, null);\n  }, createProfileWatchErrorHandler(dispatch, firebase));else if (firebase.database) firebase._.profileWatch = firebase.database().ref().child(\"\".concat(userProfile, \"/\").concat(authUid)).on(\"value\", function (userProfileSnap) {\n    enableClaims ? firebase.auth().currentUser.getIdTokenResult(!0).then(function (token) {\n      return handleProfileWatchResponse(dispatch, firebase, userProfileSnap, token);\n    }) : handleProfileWatchResponse(dispatch, firebase, userProfileSnap, null);\n  }, createProfileWatchErrorHandler(dispatch, firebase));else throw new Error(\"Real Time Database or Firestore must be included to enable user profile\");\n};\nexports.watchUserProfile = watchUserProfile;\nvar createUserProfile = function (dispatch, firebase, userData, profile) {\n  var config = firebase._.config;\n  if (!config.userProfile || !firebase.database && !firebase.firestore) return Promise.resolve(userData);\n  if (\"function\" == typeof config.profileFactory) try {\n    profile = config.profileFactory(userData, profile, firebase);\n  } catch (err) {\n    return console.error(\"Error occurred within profileFactory function:\", err.message || err), Promise.reject(err);\n  }\n  return config.useFirestoreForProfile ? firebase.firestore().collection(config.userProfile).doc(userData.uid || userData.user.uid).get().then(function (profileSnap) {\n    if (!config.updateProfileOnLogin && profileSnap.exists) return profileSnap.data();\n    var newProfile = profile;\n    if (!newProfile) {\n      var userDataObject = userData.uid ? userData.toJSON ? userData.toJSON() : userData : userData.user.toJSON ? userData.user.toJSON() : userData.user;\n      newProfile = _objectSpread(_objectSpread({}, (0, _omit2.default)(userDataObject, config.keysToRemoveFromAuth)), {}, {\n        avatarUrl: userDataObject.photoURL\n      });\n    }\n    return Array.isArray(newProfile.providerData) && (newProfile.providerData = newProfile.providerData.map(function (providerDataItem) {\n      return (0, _pick2.default)(providerDataItem, config.keysToPreserveFromProviderData);\n    })), profileSnap.ref.set(newProfile, {\n      merge: !0\n    }).then(function () {\n      return newProfile;\n    });\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      authError: err\n    }), Promise.reject(err);\n  }) : firebase.database().ref().child(\"\".concat(config.userProfile, \"/\").concat(userData.user ? userData.user.uid : userData.uid)).once(\"value\").then(function (profileSnap) {\n    return config.updateProfileOnLogin || null === profileSnap.val() ? profileSnap.ref.update(profile).then(function () {\n      return profile;\n    }) : profileSnap.val();\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      authError: err\n    }), \"function\" == typeof config.onProfileWriteError && config.onProfileWriteError(err, firebase), Promise.reject(err);\n  });\n};\nexports.createUserProfile = createUserProfile;\nvar handleAuthStateChange = function (dispatch, firebase, authData) {\n    var config = firebase._.config;\n    authData ? (firebase._.authUid = authData.uid, config.presence && (0, _auth.setupPresence)(dispatch, firebase), dispatch({\n      type: _constants.actionTypes.LOGIN,\n      auth: authData,\n      preserve: config.preserveOnLogin\n    }), watchUserProfile(dispatch, firebase), \"function\" == typeof config.onAuthStateChanged && config.onAuthStateChanged(authData, firebase, dispatch)) : (\"function\" == typeof config.onAuthStateChanged && firebase._.config.onAuthStateChanged(authData, firebase, dispatch), dispatch({\n      type: _constants.actionTypes.AUTH_EMPTY_CHANGE,\n      preserve: config.preserveOnEmptyAuthChange\n    }), unWatchUserProfile(firebase));\n  },\n  handleRedirectResult = function (dispatch, firebase, authData) {\n    if (\"function\" == typeof firebase._.config.onRedirectResult && firebase._.config.onRedirectResult(authData, firebase, dispatch), authData && authData.user) {\n      var user = authData.user;\n      return firebase._.authUid = user.uid, watchUserProfile(dispatch, firebase), dispatch({\n        type: _constants.actionTypes.LOGIN,\n        auth: user,\n        preserve: firebase._.config.preserveOnLogin\n      }), createUserProfile(dispatch, firebase, user, {\n        email: user.email,\n        displayName: user.providerData[0].displayName || user.email,\n        avatarUrl: user.providerData[0].photoURL,\n        providerData: user.providerData\n      });\n    }\n  };\nexports.handleRedirectResult = handleRedirectResult;\nvar init = function (dispatch, firebase) {\n  firebase.auth && (dispatch({\n    type: _constants.actionTypes.AUTHENTICATION_INIT_STARTED\n  }), firebase.auth().onAuthStateChanged(function (authData) {\n    return handleAuthStateChange(dispatch, firebase, authData);\n  }), firebase._.config.enableRedirectHandling && \"function\" == typeof firebase.auth().getRedirectResult && \"undefined\" != typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf(\"http\") && firebase.auth().getRedirectResult().then(function (authData) {\n    return handleRedirectResult(dispatch, firebase, authData);\n  }).catch(function (error) {\n    return dispatchLoginError(dispatch, error), Promise.reject(error);\n  }), firebase.auth().currentUser, dispatch({\n    type: _constants.actionTypes.AUTHENTICATION_INIT_FINISHED\n  }));\n};\nexports.init = init;\nvar login = function (dispatch, firebase, credentials) {\n  var _firebase$auth;\n  firebase._.config.resetBeforeLogin && dispatchLoginError(dispatch, null);\n  var _getLoginMethodAndPar = (0, _auth.getLoginMethodAndParams)(firebase, credentials),\n    method = _getLoginMethodAndPar.method,\n    params = _getLoginMethodAndPar.params;\n  return (_firebase$auth = firebase.auth())[method].apply(_firebase$auth, _toConsumableArray(params)).then(function (userData) {\n    if (!userData) return Promise.resolve(null);\n    if ([\"signInWithEmailAndPassword\", \"signInAndRetrieveDataWithEmailAndPassword\", \"signInWithEmailLink\"].includes(method)) return {\n      user: userData\n    };\n    if ([\"signInWithCustomToken\", \"signInAndRetrieveDataWithCustomToken\"].includes(method)) return firebase._.config.updateProfileOnLogin ? createUserProfile(dispatch, firebase, userData, credentials.profile) : {\n      user: userData\n    };\n    if (\"signInWithPhoneNumber\" === method) return _objectSpread(_objectSpread({}, userData), {}, {\n      confirm: function confirm(code) {\n        return userData.confirm(code).then(function (_ref) {\n          var user = _ref.user,\n            additionalUserInfo = _ref.additionalUserInfo;\n          return createUserProfile(dispatch, firebase, user, {\n            phoneNumber: user.providerData[0].phoneNumber,\n            providerData: user.providerData\n          }).then(function (profile) {\n            return {\n              profile: profile,\n              user: user,\n              additionalUserInfo: additionalUserInfo\n            };\n          });\n        });\n      }\n    });\n    var user = userData.user || userData;\n    return createUserProfile(dispatch, firebase, user, credentials.profile || {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    }).then(function (profile) {\n      return _objectSpread({\n        profile: profile\n      }, userData);\n    });\n  }).catch(function (err) {\n    return dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\nexports.login = login;\nvar reauthenticate = function (dispatch, firebase, credentials) {\n  var _firebase$auth$curren,\n    _getReauthenticateMet = (0, _auth.getReauthenticateMethodAndParams)(firebase, credentials),\n    method = _getReauthenticateMet.method,\n    params = _getReauthenticateMet.params;\n  return (_firebase$auth$curren = firebase.auth().currentUser)[method].apply(_firebase$auth$curren, _toConsumableArray(params)).then(function (userData) {\n    if (!userData) return Promise.resolve(null);\n    if (\"reauthenticateWithPhoneNumber\" === method) return _objectSpread(_objectSpread({}, userData), {}, {\n      confirm: function confirm(code) {\n        return userData.confirm(code).then(function (_ref2) {\n          var user = _ref2.user,\n            additionalUserInfo = _ref2.additionalUserInfo;\n          return createUserProfile(dispatch, firebase, user, {\n            phoneNumber: user.providerData[0].phoneNumber,\n            providerData: user.providerData\n          }).then(function (profile) {\n            return {\n              profile: profile,\n              user: user,\n              additionalUserInfo: additionalUserInfo\n            };\n          });\n        });\n      }\n    });\n    var user = userData.user || userData;\n    return createUserProfile(dispatch, firebase, user, credentials.profile || {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    }).then(function (profile) {\n      return _objectSpread({\n        profile: profile\n      }, userData);\n    });\n  }).catch(function (err) {\n    return dispatchLoginError(dispatch, err, {\n      reauthenticate: !0\n    }), Promise.reject(err);\n  });\n};\nexports.reauthenticate = reauthenticate;\nvar logout = function (dispatch, firebase) {\n  return unWatchUserProfile(firebase), firebase.auth().signOut().then(function () {\n    var action = {\n      type: _constants.actionTypes.LOGOUT\n    };\n    return firebase._.config.preserveOnLogout && (action.preserve = firebase._.config.preserveOnLogout), dispatch(action), firebase._.authUid = null, firebase;\n  });\n};\nexports.logout = logout;\nvar createUser = function (dispatch, firebase, _ref3, profile) {\n  var email = _ref3.email,\n    password = _ref3.password;\n  if (dispatchLoginError(dispatch, null), !email || !password) {\n    var error = new Error(\"Email and Password are required to create user\");\n    return dispatchLoginError(dispatch, error), Promise.reject(error);\n  }\n  return firebase.auth().createUserWithEmailAndPassword(email, password).then(function (userData) {\n    return createUserProfile(dispatch, firebase, userData, profile || {\n      email: email\n    });\n  }).catch(function (err) {\n    return dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\nexports.createUser = createUser;\nvar resetPassword = function (dispatch, firebase, email) {\n  return dispatchLoginError(dispatch, null), firebase.auth().sendPasswordResetEmail(email).catch(function (err) {\n    if (err) {\n      switch (err.code) {\n        case \"auth/user-not-found\":\n          dispatchLoginError(dispatch, _objectSpread(_objectSpread({}, err), {}, {\n            message: \"The specified user account does not exist.\"\n          }));\n          break;\n        default:\n          dispatchLoginError(dispatch, err);\n      }\n      return Promise.reject(err);\n    }\n  });\n};\nexports.resetPassword = resetPassword;\nvar confirmPasswordReset = function (dispatch, firebase, code, password) {\n  return dispatchLoginError(dispatch, null), firebase.auth().confirmPasswordReset(code, password).catch(function (err) {\n    if (err) {\n      switch (err.code) {\n        case \"auth/expired-action-code\":\n          dispatchLoginError(dispatch, new Error(\"The action code has expired.\"));\n          break;\n        case \"auth/invalid-action-code\":\n          dispatchLoginError(dispatch, new Error(\"The action code is invalid.\"));\n          break;\n        case \"auth/user-disabled\":\n          dispatchLoginError(dispatch, new Error(\"The user is disabled.\"));\n          break;\n        case \"auth/user-not-found\":\n          dispatchLoginError(dispatch, new Error(\"The user is not found.\"));\n          break;\n        case \"auth/weak-password\":\n          dispatchLoginError(dispatch, new Error(\"The password is not strong enough.\"));\n          break;\n        default:\n          dispatchLoginError(dispatch, err);\n      }\n      return Promise.reject(err);\n    }\n  });\n};\nexports.confirmPasswordReset = confirmPasswordReset;\nvar verifyPasswordResetCode = function (dispatch, firebase, code) {\n  return dispatchLoginError(dispatch, null), firebase.auth().verifyPasswordResetCode(code).catch(function (err) {\n    return err && dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\nexports.verifyPasswordResetCode = verifyPasswordResetCode;\nvar applyActionCode = function (dispatch, firebase, code) {\n  return dispatchLoginError(dispatch, null), firebase.auth().applyActionCode(code).catch(function (err) {\n    return err && dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\nexports.applyActionCode = applyActionCode;\nvar updateProfile = function (dispatch, firebase, profileUpdate, options) {\n  var config = firebase._.config;\n  dispatch({\n    type: _constants.actionTypes.PROFILE_UPDATE_START,\n    payload: profileUpdate\n  });\n  var updatePromise = config.useFirestoreForProfile ? _auth.updateProfileOnFirestore : _auth.updateProfileOnRTDB;\n  return updatePromise(firebase, profileUpdate, options).then(function (snap) {\n    return dispatch({\n      type: _constants.actionTypes.PROFILE_UPDATE_SUCCESS,\n      payload: config.useFirestoreForProfile ? snap.data() : snap.val()\n    }), snap;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.PROFILE_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\nexports.updateProfile = updateProfile;\nvar updateAuth = function (dispatch, firebase, authUpdate, updateInProfile) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_UPDATE_START,\n    payload: authUpdate\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to update auth.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_UPDATE_ERROR,\n      payload: error\n    }), Promise.reject(error);\n  }\n  return firebase.auth().currentUser.updateProfile(authUpdate).then(function (payload) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_UPDATE_SUCCESS,\n      auth: firebase.auth().currentUser\n    }), updateInProfile ? updateProfile(dispatch, firebase, authUpdate) : payload;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\nexports.updateAuth = updateAuth;\nvar updateEmail = function (dispatch, firebase, newEmail, updateInProfile) {\n  if (dispatch({\n    type: _constants.actionTypes.EMAIL_UPDATE_START,\n    payload: newEmail\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to update email.\");\n    return dispatch({\n      type: _constants.actionTypes.EMAIL_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n  return firebase.auth().currentUser.updateEmail(newEmail).then(function (payload) {\n    return dispatch({\n      type: _constants.actionTypes.EMAIL_UPDATE_SUCCESS,\n      payload: newEmail\n    }), updateInProfile ? updateProfile(dispatch, firebase, {\n      email: newEmail\n    }) : payload;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.EMAIL_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\nexports.updateEmail = updateEmail;\nvar reloadAuth = function (dispatch, firebase) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_RELOAD_START\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to reload auth.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_RELOAD_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n  return firebase.auth().currentUser.reload().then(function () {\n    var auth = firebase.auth().currentUser;\n    return dispatch({\n      type: _constants.actionTypes.AUTH_RELOAD_SUCCESS,\n      payload: auth\n    }), auth;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_RELOAD_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\nexports.reloadAuth = reloadAuth;\nvar linkWithCredential = function (dispatch, firebase, credential) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_LINK_START\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to link with credential.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n  return firebase.auth().currentUser.linkWithCredential(credential).then(function (auth) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_SUCCESS,\n      payload: auth\n    }), auth;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\nexports.linkWithCredential = linkWithCredential;\nfunction linkWithAuthDispatch(promiseFunc, args, dispatch, firebase) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_LINK_START\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to link with credential.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n  return promiseFunc.apply(void 0, _toConsumableArray(args)).then(function (auth) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_SUCCESS,\n      payload: auth\n    }), auth;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n}\nfunction linkAndRetrieveDataWithCredential(dispatch, firebase, credential) {\n  return linkWithAuthDispatch(firebase.auth().currentUser.linkAndRetrieveDataWithCredential, [credential], dispatch, firebase);\n}\nfunction linkWithPopup(dispatch, firebase, credential) {\n  return linkWithAuthDispatch(firebase.auth().currentUser.linkWithPopup, [credential], dispatch, firebase);\n}\nfunction linkWithRedirect(dispatch, firebase, provider) {\n  return linkWithAuthDispatch(firebase.auth().currentUser.linkWithRedirect, [provider], dispatch, firebase);\n}\nfunction signInWithPhoneNumber(firebase, dispatch, phoneNumber, applicationVerifier) {\n  var options = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : {};\n  return login(dispatch, firebase, _objectSpread({\n    phoneNumber: phoneNumber,\n    applicationVerifier: applicationVerifier\n  }, options));\n}","map":{"version":3,"sources":["../../src/actions/auth.js"],"names":["dispatchLoginError","dispatch","authError","params","type","actionTypes","LOGIN_ERROR","unWatchUserProfile","firebase","authUid","config","userProfile","useFirestoreForProfile","_","profileWatch","firestore","database","ref","child","off","getProfileFromSnap","snap","val","data","exists","handleProfileWatchResponse","userProfileSnap","token","profileParamsToPopulate","autoPopulateProfile","logErrors","profile","Array","isArray","console","warn","SET_PROFILE","key","then","result","path","SET","timestamp","Date","now","requesting","requested","populates","catch","err","error","UNAUTHORIZED_ERROR","message","createProfileWatchErrorHandler","onProfileListenerError","factoryResult","Promise","reject","watchUserProfile","enableClaims","collection","doc","onSnapshot","auth","currentUser","getIdTokenResult","on","Error","createUserProfile","userData","resolve","profileFactory","uid","user","get","profileSnap","updateProfileOnLogin","newProfile","userDataObject","toJSON","keysToRemoveFromAuth","avatarUrl","photoURL","providerData","map","providerDataItem","keysToPreserveFromProviderData","set","merge","once","update","onProfileWriteError","handleAuthStateChange","authData","onAuthStateChanged","AUTH_EMPTY_CHANGE","preserve","preserveOnEmptyAuthChange","presence","LOGIN","preserveOnLogin","handleRedirectResult","onRedirectResult","email","displayName","init","AUTHENTICATION_INIT_STARTED","enableRedirectHandling","getRedirectResult","window","location","protocol","indexOf","AUTHENTICATION_INIT_FINISHED","login","credentials","resetBeforeLogin","method","includes","confirm","code","additionalUserInfo","phoneNumber","reauthenticate","logout","signOut","action","LOGOUT","preserveOnLogout","createUser","password","createUserWithEmailAndPassword","resetPassword","sendPasswordResetEmail","confirmPasswordReset","verifyPasswordResetCode","applyActionCode","updateProfile","profileUpdate","options","PROFILE_UPDATE_START","payload","updatePromise","updateProfileOnFirestore","updateProfileOnRTDB","PROFILE_UPDATE_SUCCESS","PROFILE_UPDATE_ERROR","updateAuth","authUpdate","updateInProfile","AUTH_UPDATE_START","AUTH_UPDATE_ERROR","AUTH_UPDATE_SUCCESS","updateEmail","newEmail","EMAIL_UPDATE_START","EMAIL_UPDATE_ERROR","EMAIL_UPDATE_SUCCESS","reloadAuth","AUTH_RELOAD_START","AUTH_RELOAD_ERROR","reload","AUTH_RELOAD_SUCCESS","linkWithCredential","credential","AUTH_LINK_START","AUTH_LINK_ERROR","AUTH_LINK_SUCCESS","linkWithAuthDispatch","promiseFunc","args","linkAndRetrieveDataWithCredential","linkWithPopup","linkWithRedirect","provider","signInWithPhoneNumber","applicationVerifier"],"mappings":"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","sourcesContent":["import { forEach, omit, pick } from 'lodash'\nimport { actionTypes } from '../constants'\nimport { populate } from '../helpers'\nimport { isString } from '../utils'\nimport {\n  getLoginMethodAndParams,\n  getReauthenticateMethodAndParams,\n  updateProfileOnRTDB,\n  updateProfileOnFirestore,\n  setupPresence\n} from '../utils/auth'\nimport { promisesForPopulate, getPopulateObjs } from '../utils/populate'\n\n/**\n * Dispatch login error action\n * @param {Function} dispatch - Action dispatch function\n * @param {object} authError - Error object\n * @param {object} params - Supplement action params\n * @returns {any} Return of action dispatch\n * @private\n */\nfunction dispatchLoginError(dispatch, authError, params = {}) {\n  return dispatch({\n    type: actionTypes.LOGIN_ERROR,\n    ...params,\n    authError\n  })\n}\n\n/**\n * Remove listener from user profile\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport function unWatchUserProfile(firebase) {\n  const {\n    authUid,\n    config: { userProfile, useFirestoreForProfile }\n  } = firebase._\n  if (!firebase._.profileWatch) {\n    return\n  }\n  if (useFirestoreForProfile && firebase.firestore) {\n    // Call profile onSnapshot unsubscribe stored on profileWatch\n    firebase._.profileWatch()\n  } else if (userProfile && firebase.database) {\n    firebase\n      .database()\n      .ref()\n      .child(`${userProfile}/${authUid}`)\n      .off('value', firebase._.profileWatch)\n  }\n  firebase._.profileWatch = null\n}\n\n/**\n * @param {firebase.database.Snapshot|firebase.firestore.DocumentSnapshot} snap - Profile snapshot\n * @returns {object|null} Profile from snapshot\n */\nfunction getProfileFromSnap(snap) {\n  // Real Time Database\n  if (snap && snap.val) {\n    return snap.val()\n  }\n  // Firestore\n  if (snap && snap.data && snap.exists) {\n    return snap.data()\n  }\n  return null\n}\n\n/**\n * Handle response from profile listener. Works with both Real Time Database\n * and Cloud Firestore.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {firebase.database.Snapshot|firebase.firestore.DocumentSnapshot} userProfileSnap - Snapshot from profile watcher\n * @param {string} token - Token to pass along in action dispatch\n * @private\n */\nexport function handleProfileWatchResponse(\n  dispatch,\n  firebase,\n  userProfileSnap,\n  token\n) {\n  const {\n    profileParamsToPopulate,\n    autoPopulateProfile,\n    useFirestoreForProfile,\n    logErrors\n  } = firebase._.config\n  const profile = getProfileFromSnap(userProfileSnap)\n  if (\n    !profileParamsToPopulate ||\n    useFirestoreForProfile || // populating profile through firestore not yet supported\n    (!Array.isArray(profileParamsToPopulate) &&\n      !isString(profileParamsToPopulate))\n  ) {\n    if (useFirestoreForProfile && profileParamsToPopulate) {\n      console.warn('Profile population is not yet supported for Firestore') // eslint-disable-line no-console\n    }\n    dispatch({\n      type: actionTypes.SET_PROFILE,\n      profile: token ? { ...profile, token } : profile\n    })\n  } else {\n    // Convert array of populate config into an array of once query promises\n    promisesForPopulate(\n      firebase,\n      userProfileSnap.key,\n      profile,\n      profileParamsToPopulate\n    )\n      .then((data) => {\n        // Fire actions for placement of data gathered in populate into redux\n        forEach(data, (result, path) => {\n          dispatch({\n            type: actionTypes.SET,\n            path,\n            data: result,\n            timestamp: Date.now(),\n            requesting: false,\n            requested: true\n          })\n        })\n        if (!autoPopulateProfile) {\n          // Dispatch action with profile combined with populated parameters\n          dispatch({\n            type: actionTypes.SET_PROFILE,\n            profile: token ? { ...profile, token } : profile\n          })\n        } else {\n          // Auto Populate profile\n          const populates = getPopulateObjs(profileParamsToPopulate)\n          const profile = userProfileSnap.val()\n          dispatch({\n            type: actionTypes.SET_PROFILE,\n            profile: populate(\n              { profile: token ? { ...profile, token } : profile, data },\n              'profile',\n              populates\n            )\n          })\n        }\n      })\n      .catch((err) => {\n        if (logErrors) {\n          // eslint-disable-next-line no-console\n          console.error(\n            `RRF: Error retrieving data for profile population. Firebase:`,\n            err\n          )\n        }\n        // Error retrieving data for population onto profile.\n        dispatch({\n          type: actionTypes.UNAUTHORIZED_ERROR,\n          authError: `Error during profile population: ${err.message}`\n        })\n        // Update profile with un-populated version\n        dispatch({ type: actionTypes.SET_PROFILE, profile })\n      })\n  }\n}\n\n/**\n * Creates a function for handling errors from profile watcher. Used for\n * both RTDB and Firestore.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Function} Profile watch error handler function\n * @private\n */\nfunction createProfileWatchErrorHandler(dispatch, firebase) {\n  const {\n    config: { onProfileListenerError, logErrors }\n  } = firebase._\n  return function handleProfileError(err) {\n    if (logErrors) {\n      // eslint-disable-next-line no-console\n      console.error(`Error with profile listener: ${err.message || ''}`, err)\n    }\n    if (typeof onProfileListenerError === 'function') {\n      const factoryResult = onProfileListenerError(err, firebase)\n      // Return factoryResult if it is a promise\n      if (typeof factoryResult.then === 'function') {\n        return factoryResult\n      }\n    }\n    return Promise.reject(err)\n  }\n}\n\n/**\n * Watch user profile. Internally dispatches sets firebase._.profileWatch\n * and calls SET_PROFILE actions. Supports both Realtime Database and Firestore\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport const watchUserProfile = (dispatch, firebase) => {\n  const {\n    authUid,\n    config: { userProfile, useFirestoreForProfile, enableClaims }\n  } = firebase._\n  unWatchUserProfile(firebase)\n\n  if (userProfile) {\n    if (useFirestoreForProfile && firebase.firestore) {\n      firebase._.profileWatch = firebase // eslint-disable-line no-param-reassign\n        .firestore()\n        .collection(userProfile)\n        .doc(authUid)\n        .onSnapshot((userProfileSnap) => {\n          return enableClaims\n            ? firebase\n                .auth()\n                .currentUser.getIdTokenResult(true)\n                .then((token) =>\n                  handleProfileWatchResponse(\n                    dispatch,\n                    firebase,\n                    userProfileSnap,\n                    token\n                  )\n                )\n            : handleProfileWatchResponse(\n                dispatch,\n                firebase,\n                userProfileSnap,\n                null\n              )\n        }, createProfileWatchErrorHandler(dispatch, firebase))\n    } else if (firebase.database) {\n      firebase._.profileWatch = firebase // eslint-disable-line no-param-reassign\n        .database()\n        .ref()\n        .child(`${userProfile}/${authUid}`)\n        .on(\n          'value',\n          (userProfileSnap) => {\n            enableClaims\n              ? firebase\n                  .auth()\n                  .currentUser.getIdTokenResult(true)\n                  .then((token) =>\n                    handleProfileWatchResponse(\n                      dispatch,\n                      firebase,\n                      userProfileSnap,\n                      token\n                    )\n                  )\n              : handleProfileWatchResponse(\n                  dispatch,\n                  firebase,\n                  userProfileSnap,\n                  null\n                )\n          },\n          createProfileWatchErrorHandler(dispatch, firebase)\n        )\n    } else {\n      throw new Error(\n        'Real Time Database or Firestore must be included to enable user profile'\n      )\n    }\n  } else if (enableClaims) {\n    firebase._.profileWatch = firebase\n      .auth()\n      .currentUser.getIdTokenResult(true)\n      .then((token) => {\n        dispatch({\n          type: actionTypes.SET_PROFILE,\n          profile: { token }\n        })\n      })\n  }\n}\n\n/**\n * Create user profile if it does not already exist.\n * `updateProfileOnLogin: false` can be passed to config to disable updating.\n * Profile factory is applied if it exists and is a function.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} userData - User data object (response from authenticating)\n * @param {object} profile - Profile data to place in new profile\n * @returns {Promise} Resolves after creating user profile\n * @private\n */\nexport const createUserProfile = (dispatch, firebase, userData, profile) => {\n  const {\n    _: { config }\n  } = firebase\n  if (!config.userProfile || (!firebase.database && !firebase.firestore)) {\n    return Promise.resolve(userData)\n  }\n  // use profileFactory if it exists in config\n  if (typeof config.profileFactory === 'function') {\n    // catch errors in user provided profileFactory function\n    try {\n      profile = config.profileFactory(userData, profile, firebase) // eslint-disable-line no-param-reassign\n    } catch (err) {\n      /* eslint-disable no-console */\n      console.error(\n        'Error occurred within profileFactory function:',\n        err.message || err\n      )\n      /* eslint-enable no-console */\n      return Promise.reject(err)\n    }\n  }\n\n  // Check/Write profile using Firestore\n  if (config.useFirestoreForProfile) {\n    // Check for user's profile at userProfile path if provided\n    return firebase\n      .firestore()\n      .collection(config.userProfile)\n      .doc(userData.uid || userData.user.uid)\n      .get()\n      .then((profileSnap) => {\n        // Return if config for updating profile is not enabled and profile exists\n        if (!config.updateProfileOnLogin && profileSnap.exists) {\n          return profileSnap.data()\n        }\n        let newProfile = profile\n\n        // If the user did supply a profileFactory, we should use the result of it for the new Profile\n        if (!newProfile) {\n          // Convert to JSON format (to prevent issue of writing invalid type to Firestore)\n          const userDataObject = userData.uid\n            ? userData.toJSON\n              ? userData.toJSON()\n              : userData\n            : userData.user.toJSON\n            ? userData.user.toJSON()\n            : userData.user\n          // Remove unnecessary auth params (configurable) and preserve types of timestamps\n          newProfile = {\n            ...omit(userDataObject, config.keysToRemoveFromAuth),\n            avatarUrl: userDataObject.photoURL // match profile pattern used for RTDB\n          }\n        }\n\n        // Convert custom object type within Provider data to a normal object\n        if (Array.isArray(newProfile.providerData)) {\n          newProfile.providerData = newProfile.providerData.map(\n            (providerDataItem) =>\n              pick(providerDataItem, config.keysToPreserveFromProviderData)\n          )\n        }\n\n        // Create/Update the profile\n        return profileSnap.ref\n          .set(newProfile, { merge: true })\n          .then(() => newProfile)\n      })\n      .catch((err) => {\n        // Error reading user profile\n        dispatch({ type: actionTypes.UNAUTHORIZED_ERROR, authError: err })\n        return Promise.reject(err)\n      })\n  }\n\n  // Check/Write profile using Firebase RTDB\n  return firebase\n    .database()\n    .ref()\n    .child(\n      `${config.userProfile}/${\n        userData.user ? userData.user.uid : userData.uid\n      }`\n    )\n    .once('value')\n    .then(\n      (profileSnap) =>\n        // update profile only if doesn't exist or if set by config\n        !config.updateProfileOnLogin && profileSnap.val() !== null\n          ? profileSnap.val()\n          : profileSnap.ref.update(profile).then(() => profile) // Update the profile\n    )\n    .catch((err) => {\n      // Error reading user profile\n      dispatch({ type: actionTypes.UNAUTHORIZED_ERROR, authError: err })\n      if (typeof config.onProfileWriteError === 'function') {\n        config.onProfileWriteError(err, firebase)\n      }\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Auth state change handler. Handles response from firebase's onAuthStateChanged\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param  {object} authData - Auth data from firebase's onAuthStateChanged\n * @private\n */\nconst handleAuthStateChange = (dispatch, firebase, authData) => {\n  const { config } = firebase._\n  if (!authData) {\n    // Run onAuthStateChanged if it exists in config and enableEmptyAuthChanges is set to true\n    if (typeof config.onAuthStateChanged === 'function') {\n      firebase._.config.onAuthStateChanged(authData, firebase, dispatch)\n    }\n    dispatch({\n      type: actionTypes.AUTH_EMPTY_CHANGE,\n      preserve: config.preserveOnEmptyAuthChange\n    })\n\n    unWatchUserProfile(firebase)\n  } else {\n    firebase._.authUid = authData.uid // eslint-disable-line no-param-reassign\n\n    // setup presence if settings and database exist\n    if (config.presence) {\n      setupPresence(dispatch, firebase)\n    }\n\n    dispatch({\n      type: actionTypes.LOGIN,\n      auth: authData,\n      preserve: config.preserveOnLogin\n    })\n\n    watchUserProfile(dispatch, firebase)\n\n    // Run onAuthStateChanged if it exists in config\n    if (typeof config.onAuthStateChanged === 'function') {\n      config.onAuthStateChanged(authData, firebase, dispatch)\n    }\n  }\n}\n\n/**\n * Redirect result handler\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param  {object} authData - Auth data from Firebase's getRedirectResult\n * @returns {void}\n * @private\n */\nexport const handleRedirectResult = (dispatch, firebase, authData) => {\n  // Run onRedirectResult if it exists in config\n  if (typeof firebase._.config.onRedirectResult === 'function') {\n    firebase._.config.onRedirectResult(authData, firebase, dispatch)\n  }\n  if (authData && authData.user) {\n    const { user } = authData\n\n    firebase._.authUid = user.uid // eslint-disable-line no-param-reassign\n    watchUserProfile(dispatch, firebase)\n\n    dispatch({\n      type: actionTypes.LOGIN,\n      auth: user,\n      preserve: firebase._.config.preserveOnLogin\n    })\n\n    return createUserProfile(dispatch, firebase, user, {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    })\n  }\n}\n\n/**\n * Initialize authentication state change listener that\n * watches user profile and dispatches login action\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport const init = (dispatch, firebase) => {\n  // exit if auth does not exist\n  if (!firebase.auth) {\n    return\n  }\n  dispatch({ type: actionTypes.AUTHENTICATION_INIT_STARTED })\n  // Set Auth State listener\n  firebase\n    .auth()\n    .onAuthStateChanged((authData) =>\n      handleAuthStateChange(dispatch, firebase, authData)\n    )\n\n  // set redirect result callback if enableRedirectHandling set to true\n  if (\n    firebase._.config.enableRedirectHandling &&\n    typeof firebase.auth().getRedirectResult === 'function' &&\n    typeof window !== 'undefined' &&\n    window.location &&\n    window.location.protocol &&\n    window.location.protocol.indexOf('http') !== -1\n  ) {\n    firebase\n      .auth()\n      .getRedirectResult()\n      .then((authData) => handleRedirectResult(dispatch, firebase, authData))\n      .catch((error) => {\n        dispatchLoginError(dispatch, error)\n        return Promise.reject(error)\n      })\n  }\n\n  firebase.auth().currentUser // eslint-disable-line no-unused-expressions\n\n  dispatch({ type: actionTypes.AUTHENTICATION_INIT_FINISHED })\n}\n\n/**\n * Login with errors dispatched\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {object} credentials.email - Email to login with (only needed for email login)\n * @param {object} credentials.password - Password to login with (only needed for email login)\n * @param {object} credentials.provider - Provider name such as google, twitter (only needed for 3rd party provider login)\n * @param {object} credentials.type - Popup or redirect (only needed for 3rd party provider login)\n * @param {object} credentials.token - Custom or provider token\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider (i.e. email)\n * @returns {Promise} Resolves after user is logged in\n * @private\n */\nexport const login = (dispatch, firebase, credentials) => {\n  if (firebase._.config.resetBeforeLogin) {\n    dispatchLoginError(dispatch, null)\n  }\n\n  const { method, params } = getLoginMethodAndParams(firebase, credentials)\n\n  return firebase\n    .auth()\n    [method](...params)\n    .then((userData) => {\n      // Handle null response from getRedirectResult before redirect has happened\n      if (!userData) return Promise.resolve(null)\n\n      // For email auth return uid (createUser is used for creating a profile)\n      if (\n        [\n          'signInWithEmailAndPassword',\n          'signInAndRetrieveDataWithEmailAndPassword',\n          'signInWithEmailLink'\n        ].includes(method)\n      ) {\n        return { user: userData }\n      }\n      // TODO: Only call createUserProfile once, and just pass different settings\n\n      // For token auth, the user key doesn't exist. Instead, return the JWT.\n      if (\n        [\n          'signInWithCustomToken',\n          'signInAndRetrieveDataWithCustomToken'\n        ].includes(method)\n      ) {\n        if (!firebase._.config.updateProfileOnLogin) {\n          return { user: userData }\n        }\n        return createUserProfile(\n          dispatch,\n          firebase,\n          userData,\n          credentials.profile\n        )\n      }\n\n      if (method === 'signInWithPhoneNumber') {\n        // Modify confirm method to include profile creation\n        return {\n          ...userData,\n          confirm: (code) =>\n            // Call original confirm\n            userData.confirm(code).then(({ user, additionalUserInfo }) =>\n              createUserProfile(dispatch, firebase, user, {\n                phoneNumber: user.providerData[0].phoneNumber,\n                providerData: user.providerData\n              }).then((profile) => ({ profile, user, additionalUserInfo }))\n            )\n        }\n      }\n\n      // Create profile when logging in with external provider\n      const user = userData.user || userData\n\n      return createUserProfile(\n        dispatch,\n        firebase,\n        user,\n        credentials.profile || {\n          email: user.email,\n          displayName: user.providerData[0].displayName || user.email,\n          avatarUrl: user.providerData[0].photoURL,\n          providerData: user.providerData\n        }\n      ).then((profile) => ({ profile, ...userData }))\n    })\n    .catch((err) => {\n      dispatchLoginError(dispatch, err)\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Reauthenticate with errors dispatched\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {object} credentials.provider - Provider name such as google, twitter (only needed for 3rd party provider login)\n * @param {object} credentials.type - Popup or redirect (only needed for 3rd party provider login)\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider (i.e. email)\n * @returns {Promise} Resolves after user is logged in\n * @private\n */\nexport const reauthenticate = (dispatch, firebase, credentials) => {\n  const { method, params } = getReauthenticateMethodAndParams(\n    firebase,\n    credentials\n  )\n\n  return firebase\n    .auth()\n    .currentUser[method](...params)\n    .then((userData) => {\n      // Handle null response from getRedirectResult before redirect has happened\n      if (!userData) return Promise.resolve(null)\n\n      if (method === 'reauthenticateWithPhoneNumber') {\n        // Modify confirm method to include profile creation\n        return {\n          ...userData,\n          confirm: (code) =>\n            // Call original confirm\n            userData.confirm(code).then(({ user, additionalUserInfo }) =>\n              createUserProfile(dispatch, firebase, user, {\n                phoneNumber: user.providerData[0].phoneNumber,\n                providerData: user.providerData\n              }).then((profile) => ({ profile, user, additionalUserInfo }))\n            )\n        }\n      }\n\n      // Create profile when logging in with external provider\n      const user = userData.user || userData\n\n      return createUserProfile(\n        dispatch,\n        firebase,\n        user,\n        credentials.profile || {\n          email: user.email,\n          displayName: user.providerData[0].displayName || user.email,\n          avatarUrl: user.providerData[0].photoURL,\n          providerData: user.providerData\n        }\n      ).then((profile) => ({ profile, ...userData }))\n    })\n    .catch((err) => {\n      dispatchLoginError(dispatch, err, { reauthenticate: true })\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Logout of firebase and dispatch logout event\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Promise} Resolves after logging out\n * @private\n */\nexport const logout = (dispatch, firebase) => {\n  // detach profile listener before logging out to prevent permission_denied\n  // errors (for more info see #494)\n  unWatchUserProfile(firebase)\n  return firebase\n    .auth()\n    .signOut()\n    .then(() => {\n      const action = {\n        type: actionTypes.LOGOUT\n      }\n      if (firebase._.config.preserveOnLogout) {\n        action.preserve = firebase._.config.preserveOnLogout\n      }\n      dispatch(action)\n      firebase._.authUid = null\n      return firebase\n    })\n}\n\n/**\n * Create a new user in auth and add an account to userProfile root\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {string} credentials.email - Email of user\n * @param {string} credentials.password - Password of new user\n * @param {object} profile - Profile to store in database for new user\n * @returns {Promise} Resolves after user is created\n * @private\n */\nexport const createUser = (\n  dispatch,\n  firebase,\n  { email, password },\n  profile\n) => {\n  dispatchLoginError(dispatch, null)\n\n  if (!email || !password) {\n    const error = new Error('Email and Password are required to create user')\n    dispatchLoginError(dispatch, error)\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .createUserWithEmailAndPassword(email, password)\n    .then((userData) =>\n      // Login to newly created account flag is not set to false\n      createUserProfile(dispatch, firebase, userData, profile || { email })\n    )\n    .catch((err) => {\n      dispatchLoginError(dispatch, err)\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Send password reset email to provided email\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} email - Email to send recovery email to\n * @returns {Promise} Resolves after password reset email is sent\n * @private\n */\nexport const resetPassword = (dispatch, firebase, email) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .sendPasswordResetEmail(email)\n    .catch((err) => {\n      if (err) {\n        switch (err.code) {\n          case 'auth/user-not-found':\n            dispatchLoginError(dispatch, {\n              ...err,\n              message: 'The specified user account does not exist.'\n            })\n            break\n          default:\n            dispatchLoginError(dispatch, err)\n        }\n        return Promise.reject(err)\n      }\n    })\n}\n\n/**\n * Confirm the password reset with code and password\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} code - Email confirmation reset code\n * @param {string} password - Password to set it to\n * @returns {Promise} Resvoles after password reset is confirmed\n * @private\n */\nexport const confirmPasswordReset = (dispatch, firebase, code, password) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .confirmPasswordReset(code, password)\n    .catch((err) => {\n      if (err) {\n        switch (err.code) {\n          case 'auth/expired-action-code':\n            dispatchLoginError(\n              dispatch,\n              new Error('The action code has expired.')\n            )\n            break\n          case 'auth/invalid-action-code':\n            dispatchLoginError(\n              dispatch,\n              new Error('The action code is invalid.')\n            )\n            break\n          case 'auth/user-disabled':\n            dispatchLoginError(dispatch, new Error('The user is disabled.'))\n            break\n          case 'auth/user-not-found':\n            dispatchLoginError(dispatch, new Error('The user is not found.'))\n            break\n          case 'auth/weak-password':\n            dispatchLoginError(\n              dispatch,\n              new Error('The password is not strong enough.')\n            )\n            break\n          default:\n            dispatchLoginError(dispatch, err)\n        }\n        return Promise.reject(err)\n      }\n    })\n}\n\n/**\n * Verify that password reset code is valid\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} code - Password reset code\n * @returns {Promise} email - Email associated with reset code\n * @private\n */\nexport const verifyPasswordResetCode = (dispatch, firebase, code) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .verifyPasswordResetCode(code)\n    .catch((err) => {\n      if (err) {\n        dispatchLoginError(dispatch, err)\n      }\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Apply a verification code sent via email or other mechanism\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} code - Verification code\n * @returns {Promise} Resolves after applying verification code\n * @private\n */\nexport const applyActionCode = (dispatch, firebase, code) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .applyActionCode(code)\n    .catch((err) => {\n      if (err) {\n        dispatchLoginError(dispatch, err)\n      }\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Update user profile\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} profileUpdate - Update for profile\n * @param {object} options - Options object\n * @returns {Promise} Resolves after updating profile\n * @private\n */\nexport const updateProfile = (dispatch, firebase, profileUpdate, options) => {\n  const {\n    _: { config }\n  } = firebase\n  dispatch({\n    type: actionTypes.PROFILE_UPDATE_START,\n    payload: profileUpdate\n  })\n  // Select update promise type (firebase/firestore) based on config\n  const updatePromise = config.useFirestoreForProfile\n    ? updateProfileOnFirestore\n    : updateProfileOnRTDB\n  return updatePromise(firebase, profileUpdate, options)\n    .then((snap) => {\n      dispatch({\n        type: actionTypes.PROFILE_UPDATE_SUCCESS,\n        payload: config.useFirestoreForProfile ? snap.data() : snap.val()\n      })\n      return snap\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.PROFILE_UPDATE_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Update Auth Profile Object. Internally calls\n * `firebase.auth().currentUser.updateProfile` as seen [in the firebase docs](https://firebase.google.com/docs/auth/web/manage-users#update_a_users_profile).\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} authUpdate - Update for current user's auth profile\n * @param {boolean} updateInProfile - Whether or not to update in profile as well\n * @returns {Promise} Resolves with results of updating auth\n * @private\n */\nexport const updateAuth = (dispatch, firebase, authUpdate, updateInProfile) => {\n  dispatch({ type: actionTypes.AUTH_UPDATE_START, payload: authUpdate })\n\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to update auth.')\n    dispatch({ type: actionTypes.AUTH_UPDATE_ERROR, payload: error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.updateProfile(authUpdate)\n    .then((payload) => {\n      dispatch({\n        type: actionTypes.AUTH_UPDATE_SUCCESS,\n        auth: firebase.auth().currentUser\n      })\n      if (updateInProfile) {\n        return updateProfile(dispatch, firebase, authUpdate)\n      }\n      return payload\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.AUTH_UPDATE_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Update user's email within Firebase auth and optionally within\n * users's profile. Internally calls `firebase.auth().currentUser.updateEmail`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} newEmail - Update to be auth object\n * @param {boolean} updateInProfile - Whether or not to update email within\n * user's profile object (stored under path provided to userProfile config)\n * @returns {Promise} Resolves with results of updating email\n * @private\n */\nexport const updateEmail = (dispatch, firebase, newEmail, updateInProfile) => {\n  dispatch({ type: actionTypes.EMAIL_UPDATE_START, payload: newEmail })\n\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to update email.')\n    dispatch({ type: actionTypes.EMAIL_UPDATE_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.updateEmail(newEmail)\n    .then((payload) => {\n      dispatch({ type: actionTypes.EMAIL_UPDATE_SUCCESS, payload: newEmail })\n      if (updateInProfile) {\n        return updateProfile(dispatch, firebase, { email: newEmail })\n      }\n      return payload\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.EMAIL_UPDATE_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Reload Auth state. Internally calls\n * `firebase.auth().currentUser.reload`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Promise} Resolves with auth\n */\nexport const reloadAuth = (dispatch, firebase) => {\n  dispatch({ type: actionTypes.AUTH_RELOAD_START })\n\n  // reject and dispatch error if not logged in\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to reload auth.')\n    dispatch({ type: actionTypes.AUTH_RELOAD_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.reload()\n    .then(() => {\n      const auth = firebase.auth().currentUser\n      dispatch({ type: actionTypes.AUTH_RELOAD_SUCCESS, payload: auth })\n      return auth\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.AUTH_RELOAD_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkWithCredential`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credential - Credential with which to link user account\n * @returns {Promise} Resolves with auth\n */\nexport const linkWithCredential = (dispatch, firebase, credential) => {\n  dispatch({ type: actionTypes.AUTH_LINK_START })\n\n  // reject and dispatch error if not logged in\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to link with credential.')\n    dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.linkWithCredential(credential)\n    .then((auth) => {\n      dispatch({ type: actionTypes.AUTH_LINK_SUCCESS, payload: auth })\n      return auth\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * @param {Function} promiseFunc - Promise function\n * @param {Array} args - arguments to pass to function\n * @param {Function} dispatch - Redux dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Promise} Resolves after auth is linked and AUTH_LINK_SUCCESS\n * action is dispatched\n */\nfunction linkWithAuthDispatch(promiseFunc, args, dispatch, firebase) {\n  dispatch({ type: actionTypes.AUTH_LINK_START })\n\n  // reject and dispatch error if not logged in\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to link with credential.')\n    dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return promiseFunc(...args)\n    .then((auth) => {\n      dispatch({ type: actionTypes.AUTH_LINK_SUCCESS, payload: auth })\n      return auth\n    })\n    .catch((error) => {\n      dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkAndRetrieveDataWithCredential`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credential - Credential with which to link user account\n * @returns {Promise} Resolves with auth\n */\nexport function linkAndRetrieveDataWithCredential(\n  dispatch,\n  firebase,\n  credential\n) {\n  return linkWithAuthDispatch(\n    firebase.auth().currentUser.linkAndRetrieveDataWithCredential,\n    [credential],\n    dispatch,\n    firebase\n  )\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkWithPopup`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credential - Credential with which to link user account\n * @returns {Promise} Resolves with auth\n */\nexport function linkWithPopup(dispatch, firebase, credential) {\n  return linkWithAuthDispatch(\n    firebase.auth().currentUser.linkWithPopup,\n    [credential],\n    dispatch,\n    firebase\n  )\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkWithRedirect`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {any} provider - Auth provider\n * @returns {Promise} Resolves with auth\n */\nexport function linkWithRedirect(dispatch, firebase, provider) {\n  return linkWithAuthDispatch(\n    firebase.auth().currentUser.linkWithRedirect,\n    [provider],\n    dispatch,\n    firebase\n  )\n}\n\n/**\n * Asynchronously signs in using a phone number and create's\n * user profile. This method sends a code via SMS to the given phone\n * number, and returns a firebase.auth.ConfirmationResult. Internally\n * calls `firebase.auth().signInWithPhoneNumber`.\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {string} phoneNumber - Phone number\n * @param {object} applicationVerifier - Phone number\n * @param {object} options - Options object\n * @returns {Promise} Resolves with auth\n */\nexport function signInWithPhoneNumber(\n  firebase,\n  dispatch,\n  phoneNumber,\n  applicationVerifier,\n  options = {}\n) {\n  return login(dispatch, firebase, {\n    phoneNumber,\n    applicationVerifier,\n    ...options\n  })\n}\n"]},"metadata":{},"sourceType":"script"}