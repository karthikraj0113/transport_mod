{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.authIsReady = authIsReady, exports.createAuthIsReady = createAuthIsReady, exports.getLoginMethodAndParams = getLoginMethodAndParams, exports.getReauthenticateMethodAndParams = getReauthenticateMethodAndParams, exports.setupPresence = setupPresence, exports.updateProfileOnFirestore = updateProfileOnFirestore, exports.updateProfileOnRTDB = updateProfileOnRTDB;\nvar _capitalize2 = _interopRequireDefault(require(\"lodash/capitalize\")),\n  _constants = require(\"../constants\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction createAuthProvider(firebase, providerName, scopes) {\n  var lowerCaseProviderName = providerName.toLowerCase();\n  if (\"microsoft.com\" === lowerCaseProviderName || \"apple.com\" === lowerCaseProviderName || \"yahoo.com\" === lowerCaseProviderName) {\n    var _provider = new firebase.auth.OAuthProvider(providerName);\n    return _provider;\n  }\n  var capitalProviderName = \"\".concat((0, _capitalize2.default)(providerName), \"AuthProvider\");\n  if (!firebase.auth[capitalProviderName]) throw new Error(\"\".concat(providerName, \" is not a valid auth provider for your firebase instance. If using react-native, use a RN specific auth library.\"));\n  var provider = new firebase.auth[capitalProviderName](),\n    customAuthParameters = firebase._.config.customAuthParameters;\n  return (customAuthParameters && customAuthParameters[providerName] && provider.setCustomParameters(customAuthParameters[providerName]), \"twitter\" === lowerCaseProviderName || \"function\" != typeof provider.addScope) ? provider : (provider.addScope(\"email\"), scopes && (Array.isArray(scopes) && scopes.forEach(function (scope) {\n    provider.addScope(scope);\n  }), (\"string\" == typeof scopes || scopes instanceof String) && provider.addScope(scopes)), provider);\n}\nfunction getLoginMethodAndParams(firebase, credentials) {\n  var email = credentials.email,\n    password = credentials.password,\n    provider = credentials.provider,\n    type = credentials.type,\n    token = credentials.token,\n    scopes = credentials.scopes,\n    phoneNumber = credentials.phoneNumber,\n    applicationVerifier = credentials.applicationVerifier,\n    credential = credentials.credential,\n    emailLink = credentials.emailLink;\n  if (credential) {\n    var credentialAuth = firebase.auth().signInAndRetrieveDataWithCredential;\n    return credentialAuth ? {\n      method: \"signInAndRetrieveDataWithCredential\",\n      params: [credential]\n    } : {\n      method: \"signInWithCredential\",\n      params: [credential]\n    };\n  }\n  if (provider) {\n    if (-1 === _constants.supportedAuthProviders.indexOf(provider.toLowerCase())) throw new Error(\"\".concat(provider, \" is not a valid Auth Provider\"));\n    if (token) throw new Error(\"provider with token no longer supported, use credential parameter instead\");\n    var authProvider = createAuthProvider(firebase, provider, scopes);\n    return \"popup\" === type ? {\n      method: \"signInWithPopup\",\n      params: [authProvider]\n    } : {\n      method: \"signInWithRedirect\",\n      params: [authProvider]\n    };\n  }\n  if (token) {\n    var tokenAuth = firebase.auth().signInAndRetrieveDataWithCustomToken;\n    return tokenAuth ? {\n      method: \"signInAndRetrieveDataWithCustomToken\",\n      params: [token]\n    } : {\n      method: \"signInWithCustomToken\",\n      params: [token]\n    };\n  }\n  if (phoneNumber) {\n    if (!applicationVerifier) throw new Error(\"Application verifier is required for phone authentication\");\n    return {\n      method: \"signInWithPhoneNumber\",\n      params: [phoneNumber, applicationVerifier]\n    };\n  }\n  return emailLink && email ? {\n    method: \"signInWithEmailLink\",\n    params: [email, emailLink]\n  } : firebase.auth().signInWithEmailAndPassword ? {\n    method: \"signInWithEmailAndPassword\",\n    params: [email, password]\n  } : {\n    method: \"signInAndRetrieveDataWithEmailAndPassword\",\n    params: [email, password]\n  };\n}\nfunction getReauthenticateMethodAndParams(firebase, credentials) {\n  var provider = credentials.provider,\n    type = credentials.type,\n    scopes = credentials.scopes,\n    phoneNumber = credentials.phoneNumber,\n    applicationVerifier = credentials.applicationVerifier,\n    credential = credentials.credential;\n  if (credential) {\n    var credentialAuth = firebase.auth().reauthenticateAndRetrieveDataWithCredential;\n    return credentialAuth ? {\n      method: \"reauthenticateAndRetrieveDataWithCredential\",\n      params: [credential]\n    } : {\n      method: \"reauthenticateWithCredential\",\n      params: [credential]\n    };\n  }\n  if (provider) {\n    if (-1 === _constants.supportedAuthProviders.indexOf(provider.toLowerCase())) throw new Error(\"\".concat(provider, \" is not a valid Auth Provider\"));\n    var authProvider = createAuthProvider(firebase, provider, scopes);\n    return \"popup\" === type ? {\n      method: \"reauthenticateWithPopup\",\n      params: [authProvider]\n    } : {\n      method: \"reauthenticateWithRedirect\",\n      params: [authProvider]\n    };\n  }\n  if (!applicationVerifier) throw new Error(\"Application verifier is required for phone authentication\");\n  return {\n    method: \"reauthenticateWithPhoneNumber\",\n    params: [phoneNumber, applicationVerifier]\n  };\n}\nfunction isAuthReady(store, stateName) {\n  var state = store.getState(),\n    firebaseState = stateName ? state[stateName] : state,\n    firebaseAuthState = firebaseState && firebaseState.auth;\n  if (!firebaseAuthState) throw new Error(\"The Firebase auth state could not be found in the store under the attribute '\".concat(stateName ? \"\".concat(stateName, \".\") : \"\", \"auth'. Make sure your react-redux-firebase reducer is correctly set in the store\"));\n  return firebaseState.auth.isLoaded;\n}\nfunction authIsReady(store) {\n  var stateName = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : \"firebase\";\n  return new Promise(function (resolve) {\n    if (isAuthReady(store, stateName)) resolve();else var unsubscribe = store.subscribe(function () {\n      isAuthReady(store, stateName) && (unsubscribe(), resolve());\n    });\n  });\n}\nfunction createAuthIsReady(store, config) {\n  return \"function\" == typeof config.authIsReady ? config.authIsReady(store, config) : authIsReady(store, config.firebaseStateName);\n}\nfunction updateProfileOnRTDB(firebase, profileUpdate) {\n  var _firebase$_ = firebase._,\n    config = _firebase$_.config,\n    authUid = _firebase$_.authUid,\n    profileRef = firebase.database().ref(\"\".concat(config.userProfile, \"/\").concat(authUid));\n  return profileRef.update(profileUpdate).then(function () {\n    return profileRef.once(\"value\");\n  });\n}\nfunction updateProfileOnFirestore(firebase, profileUpdate) {\n  var options = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {},\n    _options$useSet = options.useSet,\n    _options$merge = options.merge,\n    firestore = firebase.firestore,\n    _firebase$_2 = firebase._,\n    config = _firebase$_2.config,\n    authUid = _firebase$_2.authUid,\n    profileRef = firestore().doc(\"\".concat(config.userProfile, \"/\").concat(authUid)),\n    profileUpdatePromise = !(void 0 !== _options$useSet) || _options$useSet ? profileRef.set(profileUpdate, {\n      merge: !(void 0 !== _options$merge) || _options$merge\n    }) : profileRef.update(profileUpdate);\n  return profileUpdatePromise.then(function () {\n    return profileRef.get();\n  });\n}\nfunction setupPresence(dispatch, firebase) {\n  if (firebase.database && firebase.database.ServerValue) {\n    var ref = firebase.database().ref(),\n      _firebase$_3 = firebase._,\n      _firebase$_3$config = _firebase$_3.config,\n      presence = _firebase$_3$config.presence,\n      sessions = _firebase$_3$config.sessions,\n      authUid = _firebase$_3.authUid,\n      amOnline = ref.child(\".info/connected\"),\n      onlineRef = ref.child(\"function\" == typeof presence ? presence(firebase.auth().currentUser, firebase) : presence).child(authUid),\n      sessionsRef = \"function\" == typeof sessions ? sessions(firebase.auth().currentUser, firebase) : sessions;\n    sessionsRef && (sessionsRef = ref.child(sessions)), amOnline.on(\"value\", function (snapShot) {\n      if (snapShot.val()) {\n        if (sessionsRef) {\n          dispatch({\n            type: _constants.actionTypes.SESSION_START,\n            payload: authUid\n          });\n          var session = sessionsRef.push({\n            startedAt: firebase.database.ServerValue.TIMESTAMP,\n            user: authUid\n          });\n          \"function\" == typeof session.setPriority && session.setPriority(authUid), session.child(\"endedAt\").onDisconnect().set(firebase.database.ServerValue.TIMESTAMP, function () {\n            dispatch({\n              type: _constants.actionTypes.SESSION_END\n            });\n          });\n        }\n        onlineRef.set(!0), onlineRef.onDisconnect().remove();\n      }\n    });\n  }\n}","map":{"version":3,"sources":["../../src/utils/auth.js"],"names":["createAuthProvider","firebase","providerName","scopes","lowerCaseProviderName","toLowerCase","provider","auth","OAuthProvider","capitalProviderName","Error","customAuthParameters","_","config","setCustomParameters","addScope","Array","isArray","forEach","scope","String","getLoginMethodAndParams","credentials","email","password","type","token","phoneNumber","applicationVerifier","credential","emailLink","credentialAuth","signInAndRetrieveDataWithCredential","method","params","indexOf","authProvider","tokenAuth","signInAndRetrieveDataWithCustomToken","signInWithEmailAndPassword","getReauthenticateMethodAndParams","reauthenticateAndRetrieveDataWithCredential","isAuthReady","store","stateName","state","getState","firebaseState","firebaseAuthState","isLoaded","authIsReady","Promise","resolve","unsubscribe","subscribe","createAuthIsReady","firebaseStateName","updateProfileOnRTDB","profileUpdate","authUid","profileRef","database","ref","userProfile","update","then","once","updateProfileOnFirestore","options","useSet","merge","firestore","doc","profileUpdatePromise","set","get","setupPresence","dispatch","ServerValue","presence","sessions","amOnline","child","onlineRef","currentUser","sessionsRef","on","snapShot","val","actionTypes","SESSION_START","payload","session","push","startedAt","TIMESTAMP","user","setPriority","onDisconnect","SESSION_END","remove"],"mappings":"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","sourcesContent":["import { capitalize } from 'lodash'\nimport { supportedAuthProviders, actionTypes } from '../constants'\n\n/**\n * @description Get correct login method and params order based on provided credentials\n * @param {object} firebase - Internal firebase object\n * @param {string} providerName - Name of Auth Provider (i.e. google, github, facebook, twitter)\n * @param {Array|string} scopes - List of scopes to add to auth provider\n * @returns {firebase.auth.AuthCredential} provider - Auth Provider\n * @private\n */\nfunction createAuthProvider(firebase, providerName, scopes) {\n  // TODO: Verify scopes are valid before adding\n  // TODO: Validate parameter inputs\n\n  const lowerCaseProviderName = providerName.toLowerCase()\n\n  if (\n    lowerCaseProviderName === 'microsoft.com' ||\n    lowerCaseProviderName === 'apple.com' ||\n    lowerCaseProviderName === 'yahoo.com'\n  ) {\n    const provider = new firebase.auth.OAuthProvider(providerName)\n    return provider\n  }\n\n  const capitalProviderName = `${capitalize(providerName)}AuthProvider`\n\n  // Throw if auth provider does not exist on Firebase instance\n  if (!firebase.auth[capitalProviderName]) {\n    throw new Error(\n      `${providerName} is not a valid auth provider for your firebase instance. If using react-native, use a RN specific auth library.`\n    )\n  }\n\n  const provider = new firebase.auth[capitalProviderName]()\n\n  // Custom Auth Parameters\n  // TODO: Validate parameter inputs\n  const { customAuthParameters } = firebase._.config\n  if (customAuthParameters && customAuthParameters[providerName]) {\n    provider.setCustomParameters(customAuthParameters[providerName])\n  }\n\n  // Handle providers without scopes\n  if (\n    lowerCaseProviderName === 'twitter' ||\n    typeof provider.addScope !== 'function'\n  ) {\n    return provider\n  }\n\n  // TODO: Verify scopes are valid before adding\n  provider.addScope('email')\n\n  if (scopes) {\n    if (Array.isArray(scopes)) {\n      scopes.forEach((scope) => {\n        provider.addScope(scope)\n      })\n    }\n    // Add single scope if it is a string\n    if (typeof scopes === 'string' || scopes instanceof String) {\n      provider.addScope(scopes)\n    }\n  }\n\n  return provider\n}\n\n/**\n * Get correct login method and params order based on provided\n * credentials\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {string} credentials.email - Email to login with (only needed for\n * email login)\n * @param {string} credentials.password - Password to login with (only needed\n * for email login)\n * @param {string} credentials.provider - Provider name such as google, twitter\n * (only needed for 3rd party provider login)\n * @param {string} credentials.type - Popup or redirect (only needed for 3rd\n * party provider login)\n * @param {string} credentials.token - Custom or provider token\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or\n * provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider\n * (i.e. email)\n * @returns {object} Method and params for calling login\n * @private\n */\nexport function getLoginMethodAndParams(firebase, credentials) {\n  const {\n    email,\n    password,\n    provider,\n    type,\n    token,\n    scopes,\n    phoneNumber,\n    applicationVerifier,\n    credential,\n    emailLink\n  } = credentials\n  // Credential Auth\n  if (credential) {\n    // Attempt to use signInAndRetrieveDataWithCredential if it exists (see #467 for more info)\n    const credentialAuth = firebase.auth().signInAndRetrieveDataWithCredential\n\n    if (credentialAuth) {\n      return {\n        method: 'signInAndRetrieveDataWithCredential',\n        params: [credential]\n      }\n    }\n    return { method: 'signInWithCredential', params: [credential] }\n  }\n\n  // Provider Auth\n  if (provider) {\n    // Verify providerName is valid\n    if (supportedAuthProviders.indexOf(provider.toLowerCase()) === -1) {\n      throw new Error(`${provider} is not a valid Auth Provider`)\n    }\n    if (token) {\n      throw new Error(\n        'provider with token no longer supported, use credential parameter instead'\n      )\n    }\n    const authProvider = createAuthProvider(firebase, provider, scopes)\n    if (type === 'popup') {\n      return { method: 'signInWithPopup', params: [authProvider] }\n    }\n    return { method: 'signInWithRedirect', params: [authProvider] }\n  }\n\n  // Token Auth\n  if (token) {\n    // Check for new sign in method (see #484 for more info)\n    const tokenAuth = firebase.auth().signInAndRetrieveDataWithCustomToken\n\n    if (tokenAuth) {\n      return { method: 'signInAndRetrieveDataWithCustomToken', params: [token] }\n    }\n\n    return { method: 'signInWithCustomToken', params: [token] }\n  }\n\n  // Phone Number Auth\n  if (phoneNumber) {\n    if (!applicationVerifier) {\n      throw new Error(\n        'Application verifier is required for phone authentication'\n      )\n    }\n    return {\n      method: 'signInWithPhoneNumber',\n      params: [phoneNumber, applicationVerifier]\n    }\n  }\n\n  // Passwordless sign-in\n  if (emailLink && email) {\n    return { method: 'signInWithEmailLink', params: [email, emailLink] }\n  }\n\n  // Check for new sign in method (see #484 for more info)\n  // Note: usage of signInAndRetrieveDataWithEmailAndPassword is now a fallback since it is deprecated (see #484 for more info)\n  if (!firebase.auth().signInWithEmailAndPassword) {\n    return {\n      method: 'signInAndRetrieveDataWithEmailAndPassword',\n      params: [email, password]\n    }\n  }\n\n  // Email/Password Auth\n  return { method: 'signInWithEmailAndPassword', params: [email, password] }\n}\n\n/**\n * Get correct reauthenticate method and params order based on provided\n * credentials\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {string} credentials.provider - Provider name such as google, twitter\n * (only needed for 3rd party provider login)\n * @param {string} credentials.type - Popup or redirect (only needed for 3rd\n * party provider login)\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or\n * provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider\n * (i.e. email)\n * @returns {object} Method and params for calling login\n * @private\n */\nexport function getReauthenticateMethodAndParams(firebase, credentials) {\n  const {\n    provider,\n    type,\n    scopes,\n    phoneNumber,\n    applicationVerifier,\n    credential\n  } = credentials\n  // Credential Auth\n  if (credential) {\n    // Attempt to use signInAndRetrieveDataWithCredential if it exists (see #467 for more info)\n    const credentialAuth = firebase.auth()\n      .reauthenticateAndRetrieveDataWithCredential\n\n    if (credentialAuth) {\n      return {\n        method: 'reauthenticateAndRetrieveDataWithCredential',\n        params: [credential]\n      }\n    }\n    return { method: 'reauthenticateWithCredential', params: [credential] }\n  }\n\n  // Provider Auth\n  if (provider) {\n    // Verify providerName is valid\n    if (supportedAuthProviders.indexOf(provider.toLowerCase()) === -1) {\n      throw new Error(`${provider} is not a valid Auth Provider`)\n    }\n    const authProvider = createAuthProvider(firebase, provider, scopes)\n    if (type === 'popup') {\n      return { method: 'reauthenticateWithPopup', params: [authProvider] }\n    }\n    return { method: 'reauthenticateWithRedirect', params: [authProvider] }\n  }\n\n  // Phone Number Auth\n  if (!applicationVerifier) {\n    throw new Error('Application verifier is required for phone authentication')\n  }\n  return {\n    method: 'reauthenticateWithPhoneNumber',\n    params: [phoneNumber, applicationVerifier]\n  }\n}\n\n/**\n * Returns a promise that completes when Firebase Auth is ready in the given\n * store using react-redux-firebase.\n * @param {object} store - The Redux store on which we want to detect if\n * Firebase auth is ready.\n * @param {string} [stateName='firebase'] - The attribute name of the\n * react-redux-firebase reducer when using multiple combined reducers.\n * 'firebase' by default. Set this to `null` to indicate that the\n * react-redux-firebase reducer is not in a combined reducer.\n * @returns {Promise} Resolves when Firebase auth is ready in the store.\n */\nfunction isAuthReady(store, stateName) {\n  const state = store.getState()\n  const firebaseState = stateName ? state[stateName] : state\n  const firebaseAuthState = firebaseState && firebaseState.auth\n  if (!firebaseAuthState) {\n    throw new Error(\n      `The Firebase auth state could not be found in the store under the attribute '${\n        stateName ? `${stateName}.` : ''\n      }auth'. Make sure your react-redux-firebase reducer is correctly set in the store`\n    )\n  }\n  return firebaseState.auth.isLoaded\n}\n\n/**\n * Returns a promise that completes when Firebase Auth is ready in the given\n * store using react-redux-firebase.\n * @param {object} store - The Redux store on which we want to detect if\n * Firebase auth is ready.\n * @param {string} [stateName='firebase'] - The attribute name of the react-redux-firebase\n * reducer when using multiple combined reducers. 'firebase' by default. Set\n * this to `null` to indicate that the react-redux-firebase reducer is not in a\n * combined reducer.\n * @returns {Promise} Resolve when Firebase auth is ready in the store.\n */\nexport function authIsReady(store, stateName = 'firebase') {\n  return new Promise((resolve) => {\n    if (isAuthReady(store, stateName)) {\n      resolve()\n    } else {\n      const unsubscribe = store.subscribe(() => {\n        if (isAuthReady(store, stateName)) {\n          unsubscribe()\n          resolve()\n        }\n      })\n    }\n  })\n}\n\n/**\n * Function that creates and authIsReady promise\n * @param {object} store - The Redux store on which we want to detect if\n * Firebase auth is ready.\n * @param {object} config - Config options for authIsReady\n * @param {string} config.authIsReady - Config options for authIsReady\n * @param {string} config.firebaseStateName - Config options for authIsReady\n * @returns {Promise} Resolves when Firebase auth is ready in the store.\n */\nexport function createAuthIsReady(store, config) {\n  return typeof config.authIsReady === 'function'\n    ? config.authIsReady(store, config)\n    : authIsReady(store, config.firebaseStateName)\n}\n\n/**\n * Update profile data on Firebase Real Time Database\n * @param {object} firebase - internal firebase object\n * @param {object} profileUpdate - Updates to profile object\n * @returns {Promise} Resolves with results of profile get\n */\nexport function updateProfileOnRTDB(firebase, profileUpdate) {\n  const {\n    _: { config, authUid }\n  } = firebase\n  const profileRef = firebase.database().ref(`${config.userProfile}/${authUid}`)\n  return profileRef.update(profileUpdate).then(() => profileRef.once('value'))\n}\n\n/**\n * Update profile data on Firestore by calling set (with merge: true) on\n * the profile.\n * @param {object} firebase - internal firebase object\n * @param {object} profileUpdate - Updates to profile object\n * @param {object} options - Options object for configuring how profile\n * update occurs\n * @param {boolean} [options.useSet=true] - Use set with merge instead of\n * update. Setting to `false` uses update (can cause issue if profile document\n * does not exist).\n * @param {boolean} [options.merge=true] - Whether or not to use merge when\n * setting profile\n * @returns {Promise} Resolves with results of profile get\n */\nexport function updateProfileOnFirestore(\n  firebase,\n  profileUpdate,\n  options = {}\n) {\n  const { useSet = true, merge = true } = options\n  const {\n    firestore,\n    _: { config, authUid }\n  } = firebase\n  const profileRef = firestore().doc(`${config.userProfile}/${authUid}`)\n  // Use set with merge (to prevent \"No document to update\") unless otherwise\n  // specificed through options\n  const profileUpdatePromise = useSet\n    ? profileRef.set(profileUpdate, { merge })\n    : profileRef.update(profileUpdate)\n  return profileUpdatePromise.then(() => profileRef.get())\n}\n\n/**\n * Start presence management for a specificed user uid.\n * Presence collection contains a list of users that are online currently.\n * Sessions collection contains a record of all user sessions.\n * This function is called within login functions if enablePresence: true.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport function setupPresence(dispatch, firebase) {\n  // exit if database does not exist on firebase instance\n  if (!firebase.database || !firebase.database.ServerValue) {\n    return\n  }\n  const ref = firebase.database().ref()\n  const {\n    config: { presence, sessions },\n    authUid\n  } = firebase._\n  const amOnline = ref.child('.info/connected')\n  const onlineRef = ref\n    .child(\n      typeof presence === 'function'\n        ? presence(firebase.auth().currentUser, firebase)\n        : presence\n    )\n    .child(authUid)\n  let sessionsRef =\n    typeof sessions === 'function'\n      ? sessions(firebase.auth().currentUser, firebase)\n      : sessions\n  if (sessionsRef) {\n    sessionsRef = ref.child(sessions)\n  }\n  amOnline.on('value', (snapShot) => {\n    if (!snapShot.val()) return\n    // user is online\n    if (sessionsRef) {\n      // add session and set disconnect\n      dispatch({ type: actionTypes.SESSION_START, payload: authUid })\n      // add new session to sessions collection\n      const session = sessionsRef.push({\n        startedAt: firebase.database.ServerValue.TIMESTAMP,\n        user: authUid\n      })\n      // Support versions of react-native-firebase that do not have setPriority\n      // on firebase.database.ThenableReference\n      if (typeof session.setPriority === 'function') {\n        // set authUid as priority for easy sorting\n        session.setPriority(authUid)\n      }\n      session\n        .child('endedAt')\n        .onDisconnect()\n        .set(firebase.database.ServerValue.TIMESTAMP, () => {\n          dispatch({ type: actionTypes.SESSION_END })\n        })\n    }\n    // add correct session id to user\n    // remove from presence list\n    onlineRef.set(true)\n    onlineRef.onDisconnect().remove()\n  })\n}\n"]},"metadata":{},"sourceType":"script"}