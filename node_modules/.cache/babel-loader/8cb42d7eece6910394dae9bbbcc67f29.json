{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.deleteFile = deleteFile, exports.uploadFile = uploadFile, exports.uploadFiles = uploadFiles;\nvar _map2 = _interopRequireDefault(require(\"lodash/map\")),\n  _constants = require(\"../constants\"),\n  _actions = require(\"../utils/actions\"),\n  _storage = require(\"../utils/storage\"),\n  _excluded = [\"files\"];\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (null == source) return {};\n  var key,\n    i,\n    target = _objectWithoutPropertiesLoose(source, excluded);\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) key = sourceSymbolKeys[i], 0 <= excluded.indexOf(key) || Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (null == source) return {};\n  var key,\n    i,\n    target = {},\n    sourceKeys = Object.keys(source);\n  for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], 0 <= excluded.indexOf(key) || (target[key] = source[key]);\n  return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\nvar FILE_UPLOAD_START = _constants.actionTypes.FILE_UPLOAD_START,\n  FILE_UPLOAD_ERROR = _constants.actionTypes.FILE_UPLOAD_ERROR,\n  FILE_UPLOAD_COMPLETE = _constants.actionTypes.FILE_UPLOAD_COMPLETE,\n  FILE_DELETE_START = _constants.actionTypes.FILE_DELETE_START,\n  FILE_DELETE_ERROR = _constants.actionTypes.FILE_DELETE_ERROR,\n  FILE_DELETE_COMPLETE = _constants.actionTypes.FILE_DELETE_COMPLETE;\nfunction uploadFile(dispatch, firebase, config) {\n  if (!firebase.storage) throw new Error(\"Firebase storage is required to upload files\");\n  var _ref = config || {},\n    path = _ref.path,\n    file = _ref.file,\n    dbPath = _ref.dbPath,\n    _ref$options = _ref.options,\n    options = void 0 === _ref$options ? {\n      progress: !1\n    } : _ref$options,\n    fileMetadata = (options || {}).metadata,\n    logErrors = firebase._.config.logErrors,\n    nameFromOptions = \"function\" == typeof options.name ? options.name(file, firebase, config) : options.name,\n    filename = nameFromOptions || file.name,\n    meta = _objectSpread(_objectSpread({}, config), {}, {\n      filename: filename\n    });\n  dispatch({\n    type: FILE_UPLOAD_START,\n    payload: _objectSpread(_objectSpread({}, config), {}, {\n      filename: filename\n    })\n  });\n  return function uploadPromise() {\n    return options.progress ? (0, _storage.uploadFileWithProgress)(dispatch, firebase, {\n      path: path,\n      file: file,\n      filename: filename,\n      meta: meta,\n      fileMetadata: fileMetadata\n    }) : firebase.storage().ref(\"\".concat(path, \"/\").concat(filename)).put(file, fileMetadata);\n  }().then(function (uploadTaskSnapshot) {\n    return dbPath && (firebase.database || firebase.firestore) ? (0, _storage.writeMetadataToDb)({\n      firebase: firebase,\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      dbPath: dbPath,\n      options: options\n    }).then(function (payload) {\n      return dispatch({\n        type: FILE_UPLOAD_COMPLETE,\n        meta: _objectSpread(_objectSpread({}, config), {}, {\n          filename: filename\n        }),\n        payload: payload\n      }), payload;\n    }) : (dispatch({\n      type: FILE_UPLOAD_COMPLETE,\n      meta: _objectSpread(_objectSpread({}, config), {}, {\n        filename: filename\n      }),\n      payload: {\n        uploadTaskSnapshot: uploadTaskSnapshot,\n        uploadTaskSnaphot: uploadTaskSnapshot\n      }\n    }), {\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      uploadTaskSnaphot: uploadTaskSnapshot\n    });\n  }).catch(function (err) {\n    return logErrors && console.error && console.error(\"RRF: Error uploading file: \".concat(err.message || err), err), dispatch({\n      type: FILE_UPLOAD_ERROR,\n      path: path,\n      payload: err\n    }), Promise.reject(err);\n  });\n}\nfunction uploadFiles(dispatch, firebase, _ref3) {\n  var files = _ref3.files,\n    other = _objectWithoutProperties(_ref3, _excluded);\n  return Promise.all((0, _map2.default)(files, function (file) {\n    return uploadFile(dispatch, firebase, _objectSpread({\n      file: file\n    }, other));\n  }));\n}\nfunction deleteFile(dispatch, firebase, _ref4) {\n  var path = _ref4.path,\n    dbPath = _ref4.dbPath;\n  return (0, _actions.wrapInDispatch)(dispatch, {\n    method: _storage.deleteFile,\n    args: [firebase, {\n      path: path,\n      dbPath: dbPath\n    }],\n    types: [FILE_DELETE_START, FILE_DELETE_COMPLETE, FILE_DELETE_ERROR]\n  });\n}","map":{"version":3,"sources":["../../src/actions/storage.js"],"names":["FILE_UPLOAD_START","FILE_UPLOAD_ERROR","FILE_UPLOAD_COMPLETE","FILE_DELETE_START","FILE_DELETE_ERROR","FILE_DELETE_COMPLETE","actionTypes","uploadFile","dispatch","firebase","config","storage","Error","path","file","dbPath","options","progress","metadata","fileMetadata","logErrors","_","nameFromOptions","name","filename","meta","type","payload","uploadPromise","ref","put","then","uploadTaskSnapshot","database","firestore","uploadTaskSnaphot","catch","err","console","error","message","Promise","reject","uploadFiles","files","other","all","deleteFile","method","deleteFileFromFb","args","types"],"mappings":"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","sourcesContent":["import { map } from 'lodash'\nimport { actionTypes } from '../constants'\nimport { wrapInDispatch } from '../utils/actions'\nimport {\n  deleteFile as deleteFileFromFb,\n  writeMetadataToDb,\n  uploadFileWithProgress\n} from '../utils/storage'\n\nconst {\n  FILE_UPLOAD_START,\n  FILE_UPLOAD_ERROR,\n  FILE_UPLOAD_COMPLETE,\n  FILE_DELETE_START,\n  FILE_DELETE_ERROR,\n  FILE_DELETE_COMPLETE\n} = actionTypes\n\n/**\n * Upload file to Firebase Storage with option to store\n * file metadata within Firebase Database\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} config - Config object\n * @param {string} config.path - Location within Firebase Stroage at which to upload files.\n * @param {Blob} config.file - File Blob to be uploaded\n * @param {string} config.dbPath - Datbase path to write file meta data to\n * @param {object} config.options - Options\n * @param {string|Function} config.options.name - Name of file. If a function\n * is provided it recieves (fileObject, internalFirebase, config) as arguments.\n * @param {object} config.options.metdata - Metadata for file to be passed along\n * to storage.put calls\n * @param {object} config.options.documentId - Id of document to update with metadata if using Firestore\n * @returns {Promise} Resolves with meta object\n * @private\n */\nexport function uploadFile(dispatch, firebase, config) {\n  if (!firebase.storage) {\n    throw new Error('Firebase storage is required to upload files')\n  }\n  const { path, file, dbPath, options = { progress: false } } = config || {}\n  const { metadata: fileMetadata } = options || {}\n  const { logErrors } = firebase._.config\n\n  // File renaming through options (supporting string and function)\n  const nameFromOptions =\n    typeof options.name === 'function'\n      ? options.name(file, firebase, config)\n      : options.name\n  const filename = nameFromOptions || file.name\n\n  const meta = { ...config, filename }\n\n  // Dispatch start action\n  dispatch({ type: FILE_UPLOAD_START, payload: { ...config, filename } })\n\n  const uploadPromise = () =>\n    options.progress\n      ? uploadFileWithProgress(dispatch, firebase, {\n          path,\n          file,\n          filename,\n          meta,\n          fileMetadata\n        })\n      : firebase.storage().ref(`${path}/${filename}`).put(file, fileMetadata)\n\n  return uploadPromise()\n    .then((uploadTaskSnapshot) => {\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        dispatch({\n          type: FILE_UPLOAD_COMPLETE,\n          meta: { ...config, filename },\n          payload: {\n            uploadTaskSnapshot,\n            uploadTaskSnaphot: uploadTaskSnapshot // Preserving legacy typo\n          }\n        })\n        return {\n          uploadTaskSnapshot,\n          uploadTaskSnaphot: uploadTaskSnapshot // Preserving legacy typo\n        }\n      }\n\n      // Write File metadata to either Real Time Database or Firestore (depending on config)\n      return writeMetadataToDb({\n        firebase,\n        uploadTaskSnapshot,\n        dbPath,\n        options\n      }).then((payload) => {\n        dispatch({\n          type: FILE_UPLOAD_COMPLETE,\n          meta: { ...config, filename },\n          payload\n        })\n        return payload\n      })\n    })\n    .catch((err) => {\n      if (logErrors) {\n        /* eslint-disable no-console */\n        console.error &&\n          console.error(`RRF: Error uploading file: ${err.message || err}`, err)\n        /* eslint-enable no-console */\n      }\n      dispatch({ type: FILE_UPLOAD_ERROR, path, payload: err })\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Upload multiple files to Firebase Storage with option to store\n * file's metadata within Firebase Database\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - Options object\n * @param {string} opts.path - Storage path to write files to\n * @param {Array} opts.files - List of files to be uploaded\n * @param {string} opts.dbPath - Datbase path to write file meta data to\n * @returns {Promise} Resolves with array of meta objects\n * @private\n */\nexport function uploadFiles(dispatch, firebase, { files, ...other }) {\n  return Promise.all(\n    map(files, (file) => uploadFile(dispatch, firebase, { file, ...other }))\n  )\n}\n\n/**\n * Delete File from Firebase Storage with option to remove meta\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - Options object\n * @param {string} opts.path - Storage path to write files to\n * @param {string} opts.dbPath - Datbase path to write file meta data to\n * @returns {Promise} Resolves with results of deleting a file from storage\n * @private\n */\nexport function deleteFile(dispatch, firebase, { path, dbPath }) {\n  return wrapInDispatch(dispatch, {\n    method: deleteFileFromFb,\n    args: [firebase, { path, dbPath }],\n    types: [FILE_DELETE_START, FILE_DELETE_COMPLETE, FILE_DELETE_ERROR]\n  })\n}\n"]},"metadata":{},"sourceType":"script"}