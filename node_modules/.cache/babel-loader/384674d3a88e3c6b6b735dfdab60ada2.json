{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nexports.setupLock = setupLock;\nexports.handleAuthCallback = handleAuthCallback;\nexports.resumeAuth = resumeAuth;\nexports.openLock = openLock;\nexports.closeLock = closeLock;\nexports.removeLock = removeLock;\nexports.updateLock = updateLock;\nexports.pinLoadingPane = pinLoadingPane;\nexports.unpinLoadingPane = unpinLoadingPane;\nexports.validateAndSubmit = validateAndSubmit;\nexports.logIn = logIn;\nexports.checkSession = checkSession;\nexports.logInSuccess = logInSuccess;\nvar _immutable = require('immutable');\nvar _immutable2 = _interopRequireDefault(_immutable);\nvar _web_api = require('./web_api');\nvar _web_api2 = _interopRequireDefault(_web_api);\nvar _index = require('../store/index');\nvar _remote_data = require('./remote_data');\nvar _index2 = require('./index');\nvar l = _interopRequireWildcard(_index2);\nvar _preload_utils = require('../utils/preload_utils');\nvar _container = require('../ui/box/container');\nvar _index3 = require('../field/index');\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction setupLock(id, clientID, domain, options, hookRunner, emitEventFn, handleEventFn) {\n  var m = l.setup(id, clientID, domain, options, hookRunner, emitEventFn, handleEventFn);\n  m = (0, _remote_data.syncRemoteData)(m);\n  (0, _preload_utils.img)(l.ui.logo(m) || _container.defaultProps.logo);\n  _web_api2.default.setupClient(id, clientID, domain, l.withAuthOptions(m, _extends({}, options, {\n    popupOptions: l.ui.popupOptions(m)\n  })));\n  m = l.runHook(m, 'didInitialize', options);\n  (0, _index.swap)(_index.setEntity, 'lock', id, m);\n  return m;\n}\nfunction handleAuthCallback() {\n  var ms = (0, _index.read)(_index.getCollection, 'lock');\n  var keepHash = ms.filter(function (m) {\n    return !l.hashCleanup(m);\n  }).size > 0;\n  var urlWithoutHash = window.location.href.split('#')[0];\n  var callback = function callback(error, authResult) {\n    var parsed = !!(error || authResult);\n    if (parsed && !keepHash) {\n      window.history.replaceState(null, '', urlWithoutHash);\n    }\n  };\n  resumeAuth(window.location.hash, callback);\n}\nfunction resumeAuth(hash, callback) {\n  var ms = (0, _index.read)(_index.getCollection, 'lock');\n  ms.forEach(function (m) {\n    return l.auth.redirect(m) && parseHash(m, hash, callback);\n  });\n}\nfunction parseHash(m, hash, cb) {\n  _web_api2.default.parseHash(l.id(m), hash, function (error, authResult) {\n    if (error) {\n      l.emitHashParsedEvent(m, error);\n    } else {\n      l.emitHashParsedEvent(m, authResult);\n    }\n    if (error) {\n      l.emitAuthorizationErrorEvent(m, error);\n    } else if (authResult) {\n      l.emitAuthenticatedEvent(m, authResult);\n    }\n    cb(error, authResult);\n  });\n}\nfunction openLock(id, opts) {\n  var m = (0, _index.read)(_index.getEntity, 'lock', id);\n  if (!m) {\n    throw new Error(\"The Lock can't be opened again after it has been destroyed\");\n  }\n  if (l.rendering(m)) {\n    return false;\n  }\n  if (opts.flashMessage) {\n    var supportedTypes = ['error', 'success', 'info'];\n    if (!opts.flashMessage.type || supportedTypes.indexOf(opts.flashMessage.type) === -1) {\n      return l.emitUnrecoverableErrorEvent(m, \"'flashMessage' must provide a valid type ['error','success','info']\");\n    }\n    if (!opts.flashMessage.text) {\n      return l.emitUnrecoverableErrorEvent(m, \"'flashMessage' must provide a text\");\n    }\n  }\n  l.emitEvent(m, 'show');\n  (0, _index.swap)(_index.updateEntity, 'lock', id, function (m) {\n    m = l.overrideOptions(m, opts);\n    m = l.filterConnections(m);\n    m = l.runHook(m, 'willShow', opts);\n    return l.render(m);\n  });\n  return true;\n}\nfunction closeLock(id) {\n  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\n  // Do nothing when the Lock can't be closed, unless closing is forced.\n  var m = (0, _index.read)(_index.getEntity, 'lock', id);\n  if (!l.ui.closable(m) && !force || !l.rendering(m)) {\n    return;\n  }\n  l.emitEvent(m, 'hide');\n\n  // If it is a modal, stop rendering an reset after a second,\n  // otherwise just reset.\n  if (l.ui.appendContainer(m)) {\n    (0, _index.swap)(_index.updateEntity, 'lock', id, l.stopRendering);\n    setTimeout(function () {\n      (0, _index.swap)(_index.updateEntity, 'lock', id, function (m) {\n        m = (0, _index3.hideInvalidFields)(m);\n        m = l.reset(m);\n        m = (0, _index3.clearFields)(m);\n        return m;\n      });\n      m = (0, _index.read)(_index.getEntity, 'lock', id);\n      callback(m);\n    }, 1000);\n  } else {\n    (0, _index.swap)(_index.updateEntity, 'lock', id, function (m) {\n      m = (0, _index3.hideInvalidFields)(m);\n      m = l.reset(m);\n      m = (0, _index3.clearFields)(m);\n      return m;\n    });\n    callback(m);\n  }\n}\nfunction removeLock(id) {\n  (0, _index.swap)(_index.updateEntity, 'lock', id, l.stopRendering);\n  (0, _index.swap)(_index.removeEntity, 'lock', id);\n}\nfunction updateLock(id, f) {\n  return (0, _index.swap)(_index.updateEntity, 'lock', id, f);\n}\nfunction pinLoadingPane(id) {\n  var lock = (0, _index.read)(_index.getEntity, 'lock', id);\n  if (!lock.get('isLoadingPanePinned')) {\n    (0, _index.swap)(_index.updateEntity, 'lock', id, function (m) {\n      return m.set('isLoadingPanePinned', true);\n    });\n  }\n}\nfunction unpinLoadingPane(id) {\n  (0, _index.swap)(_index.updateEntity, 'lock', id, function (m) {\n    return m.set('isLoadingPanePinned', false);\n  });\n}\nfunction validateAndSubmit(id) {\n  var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var f = arguments[2];\n  (0, _index.swap)(_index.updateEntity, 'lock', id, function (m) {\n    var allFieldsValid = fields.reduce(function (r, x) {\n      return r && (0, _index3.isFieldValid)(m, x);\n    }, true);\n    return allFieldsValid ? l.setSubmitting(m, true) : fields.reduce(function (r, x) {\n      return (0, _index3.showInvalidField)(r, x);\n    }, m);\n  });\n  var m = (0, _index.read)(_index.getEntity, 'lock', id);\n  if (l.submitting(m)) {\n    f(m);\n  }\n}\nfunction logIn(id, fields) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var logInErrorHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (_id, error, _fields, next) {\n    return next();\n  };\n  validateAndSubmit(id, fields, function (m) {\n    try {\n      // For now, always pass 'null' for the context as we don't need it yet.\n      // If we need it later, it'll save a breaking change in hooks already in use.\n      var context = null;\n      l.runHook(m, 'loggingIn', context, function () {\n        _web_api2.default.logIn(id, params, l.auth.params(m).toJS(), function (error, result) {\n          if (error) {\n            setTimeout(function () {\n              return logInError(id, fields, error, logInErrorHandler);\n            }, 250);\n          } else {\n            logInSuccess(id, result);\n          }\n        });\n      });\n    } catch (e) {\n      setTimeout(function () {\n        return logInError(id, fields, e, logInErrorHandler);\n      }, 250);\n    }\n  });\n}\nfunction checkSession(id) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var m = (0, _index.read)(_index.getEntity, 'lock', id);\n  (0, _index.swap)(_index.updateEntity, 'lock', id, function (m) {\n    return l.setSubmitting(m, true);\n  });\n  _web_api2.default.checkSession(id, params, function (err, result) {\n    if (err) {\n      return logInError(id, [], err);\n    }\n    return logInSuccess(id, result);\n  });\n}\nfunction logInSuccess(id, result) {\n  var m = (0, _index.read)(_index.getEntity, 'lock', id);\n  if (!l.ui.autoclose(m)) {\n    (0, _index.swap)(_index.updateEntity, 'lock', id, function (m) {\n      m = l.setSubmitting(m, false);\n      return l.setLoggedIn(m, true);\n    });\n    l.emitAuthenticatedEvent(m, result);\n  } else {\n    closeLock(id, false, function (m1) {\n      return l.emitAuthenticatedEvent(m1, result);\n    });\n  }\n}\nfunction logInError(id, fields, error) {\n  var localHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (_id, _error, _fields, next) {\n    return next();\n  };\n  var errorCode = error.error || error.code;\n  localHandler(id, error, fields, function () {\n    return setTimeout(function () {\n      var m = (0, _index.read)(_index.getEntity, 'lock', id);\n      var errorMessage = l.loginErrorMessage(m, error, loginType(fields));\n      var errorCodesThatEmitAuthorizationErrorEvent = ['blocked_user', 'rule_error', 'lock.unauthorized', 'invalid_user_password', 'login_required'];\n      if (errorCodesThatEmitAuthorizationErrorEvent.indexOf(errorCode) > -1) {\n        l.emitAuthorizationErrorEvent(m, error);\n      }\n      (0, _index.swap)(_index.updateEntity, 'lock', id, l.setSubmitting, false, errorMessage);\n    }, 0);\n  });\n  (0, _index.swap)(_index.updateEntity, 'lock', id, l.setSubmitting, false);\n}\nfunction loginType(fields) {\n  if (!fields) return;\n  if (~fields.indexOf('vcode')) return 'code';\n  if (~fields.indexOf('username')) return 'username';\n  if (~fields.indexOf('email')) return 'email';\n}","map":null,"metadata":{},"sourceType":"script"}