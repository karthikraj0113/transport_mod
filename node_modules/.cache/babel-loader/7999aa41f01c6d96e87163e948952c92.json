{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nexports.setField = setField;\nexports.registerOptionField = registerOptionField;\nexports.setOptionField = setOptionField;\nexports.isFieldValid = isFieldValid;\nexports.getFieldInvalidHint = getFieldInvalidHint;\nexports.isFieldVisiblyInvalid = isFieldVisiblyInvalid;\nexports.showInvalidField = showInvalidField;\nexports.hideInvalidFields = hideInvalidFields;\nexports.setFieldShowInvalid = setFieldShowInvalid;\nexports.clearFields = clearFields;\nexports.getField = getField;\nexports.getFieldValue = getFieldValue;\nexports.getFieldLabel = getFieldLabel;\nexports.phoneNumber = phoneNumber;\nexports.email = email;\nexports.vcode = vcode;\nexports.password = password;\nexports.username = username;\nexports.mfaCode = mfaCode;\nexports.isSelecting = isSelecting;\nexports.renderOptionSelection = renderOptionSelection;\nvar _react = require('react');\nvar _react2 = _interopRequireDefault(_react);\nvar _immutable = require('immutable');\nvar _trim = require('trim');\nvar _trim2 = _interopRequireDefault(_trim);\nvar _option_selection_pane = require('./option_selection_pane');\nvar _option_selection_pane2 = _interopRequireDefault(_option_selection_pane);\nvar _index = require('../core/index');\nvar l = _interopRequireWildcard(_index);\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar minMax = function minMax(value, min, max) {\n  return value.length >= min && value.length <= max;\n};\nvar getDefaultValidator = function getDefaultValidator(field) {\n  switch (field) {\n    case 'family_name':\n    case 'given_name':\n      return function (str) {\n        return minMax((0, _trim2.default)(str), 1, 150);\n      };\n    case 'name':\n      return function (str) {\n        return minMax((0, _trim2.default)(str), 1, 300);\n      };\n    case 'nickname':\n      return function (str) {\n        return minMax((0, _trim2.default)(str), 1, 300);\n      };\n    default:\n      return function (str) {\n        return (0, _trim2.default)(str).length > 0;\n      };\n  }\n};\nfunction setField(m, field, value) {\n  var validator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getDefaultValidator(field);\n  var prevValue = m.getIn(['field', field, 'value']);\n  var prevShowInvalid = m.getIn(['field', field, 'showInvalid'], false);\n  for (var _len = arguments.length, args = Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n    args[_key - 4] = arguments[_key];\n  }\n  var validation = validate.apply(undefined, [validator, value].concat(args));\n  return m.mergeIn(['field', field], validation.merge({\n    value: value,\n    showInvalid: prevShowInvalid && prevValue === value\n  }));\n}\nfunction validate(validator, value) {\n  if (typeof validator != 'function') return (0, _immutable.Map)({\n    valid: true\n  });\n  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n  var validation = validator.apply(undefined, [value].concat(args));\n  return validation && (typeof validation === 'undefined' ? 'undefined' : _typeof(validation)) === 'object' ? (0, _immutable.Map)({\n    valid: validation.valid,\n    invalidHint: validation.hint\n  }) : (0, _immutable.Map)({\n    valid: !!validation\n  });\n}\n\n// TODO: this should handle icons, and everything.\n// TODO: also there should be a similar fn for regular fields.\nfunction registerOptionField(m, field, options, initialValue) {\n  var valid = true,\n    hasInitial = !initialValue,\n    initialOption = void 0;\n  options.forEach(function (x) {\n    valid = valid && x.get('label') && typeof x.get('label') === 'string' && x.get('value') && typeof x.get('value') === 'string';\n    if (!hasInitial && x.get('value') === initialValue) {\n      initialOption = x;\n      hasInitial = true;\n    }\n  });\n  if (!valid || !options.size) {\n    var stopError = new Error('The options provided for the \"' + field + '\" field are invalid, they must have the following format: {label: \"non-empty string\", value: \"non-empty string\"} and there has to be at least one option.');\n    stopError.code = 'invalid_select_field';\n    // TODO: in the future we might want to return the result of the\n    // operation along with the model instead of stopping the\n    // rendering, like [false, m] in the case of failure and [true, m]\n    // in the case of success.\n    return l.stop(m, stopError);\n  }\n  if (!initialOption) initialOption = (0, _immutable.Map)({});\n  return m.mergeIn(['field', field], initialOption, (0, _immutable.Map)({\n    options: options,\n    showInvalid: false,\n    valid: !initialOption.isEmpty()\n  }));\n}\nfunction setOptionField(m, field, option) {\n  return m.mergeIn(['field', field], option.merge((0, _immutable.Map)({\n    valid: true,\n    showInvalid: false\n  })));\n}\nfunction isFieldValid(m, field) {\n  return m.getIn(['field', field, 'valid']);\n}\nfunction getFieldInvalidHint(m, field) {\n  return m.getIn(['field', field, 'invalidHint'], '');\n}\nfunction isFieldVisiblyInvalid(m, field) {\n  return m.getIn(['field', field, 'showInvalid'], false) && !m.getIn(['field', field, 'valid']);\n}\nfunction showInvalidField(m, field) {\n  return m.setIn(['field', field, 'showInvalid'], !isFieldValid(m, field));\n}\nfunction hideInvalidFields(m) {\n  return m.update('field', function (fields) {\n    return fields && fields.map(function (field) {\n      return field.set('showInvalid', false);\n    });\n  });\n}\n\n// TODO: only used in passwordless, when we update it to use\n// validateAndSubmit this won't be needed anymore.\nfunction setFieldShowInvalid(m, field, value) {\n  return m.setIn(['field', field, 'showInvalid'], value);\n}\nfunction clearFields(m, fields) {\n  var keyPaths = void 0;\n  if (!fields || fields.length === 0) {\n    keyPaths = [['field']];\n  } else {\n    keyPaths = fields.map(function (x) {\n      return ['field', x];\n    });\n  }\n  return keyPaths.reduce(function (r, v) {\n    return r.removeIn(v);\n  }, m);\n}\nfunction getField(m, field) {\n  var notFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _immutable.Map({});\n  return m.getIn(['field', field], notFound);\n}\nfunction getFieldValue(m, field) {\n  var notFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return getField(m, field).get('value', notFound);\n}\nfunction getFieldLabel(m, field) {\n  var notFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return getField(m, field).get('label', notFound);\n}\n\n// phone number\n\nfunction phoneNumber(lock) {\n  return lock.getIn(['field', 'phoneNumber', 'value'], '');\n}\n\n// email\n\nfunction email(m) {\n  return getFieldValue(m, 'email');\n}\n\n// vcode\n\nfunction vcode(m) {\n  return getFieldValue(m, 'vcode');\n}\n\n// password\n\nfunction password(m) {\n  return getFieldValue(m, 'password');\n}\n\n// username\n\nfunction username(m) {\n  return getFieldValue(m, 'username');\n}\n\n// mfa_code\n\nfunction mfaCode(m) {\n  return getFieldValue(m, 'mfa_code');\n}\n\n// select field options\n\nfunction isSelecting(m) {\n  return !!m.getIn(['field', 'selecting']);\n}\nfunction renderOptionSelection(m) {\n  var name = m.getIn(['field', 'selecting', 'name']);\n  return isSelecting(m) ? _react2.default.createElement(_option_selection_pane2.default, {\n    model: m,\n    name: name,\n    icon: m.getIn(['field', 'selecting', 'icon']),\n    iconUrl: m.getIn(['field', 'selecting', 'iconUrl']),\n    items: m.getIn(['field', name, 'options'])\n  }) : null;\n}","map":null,"metadata":{},"sourceType":"script"}