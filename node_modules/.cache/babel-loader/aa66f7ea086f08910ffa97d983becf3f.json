{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.applyParamsToQuery = applyParamsToQuery, exports.getQueryIdFromPath = getQueryIdFromPath, exports.getWatchPath = getWatchPath, exports.getWatcherCount = getWatcherCount, exports.orderedFromSnapshot = orderedFromSnapshot, exports.populateAndDispatch = populateAndDispatch, exports.setWatcher = setWatcher, exports.unsetWatcher = unsetWatcher;\nvar _forEach2 = _interopRequireDefault(require(\"lodash/forEach\")),\n  _isNaN2 = _interopRequireDefault(require(\"lodash/isNaN\")),\n  _constants = require(\"../constants\"),\n  _populate = require(\"./populate\"),\n  _index = require(\"./index\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction tryParseToNumber(value) {\n  var result = +value;\n  return (0, _isNaN2.default)(result) ? value : result;\n}\nfunction getWatchPath(event, path) {\n  if (!event || \"\" === event || !path) throw new Error(\"Event and path are required\");\n  return \"\".concat(event, \":\").concat(\"/\" === path.substring(0, 1) ? \"\" : \"/\").concat(path);\n}\nfunction getQueryIdFromPath(path, event) {\n  if (!(0, _index.isString)(path)) throw new Error(\"Query path must be a string\");\n  var origPath = path,\n    pathSplitted = path.split(\"#\");\n  path = pathSplitted[0];\n  var isQuery = 1 < pathSplitted.length,\n    queryParams = isQuery ? pathSplitted[1].split(\"&\") : [],\n    queryId = isQuery ? queryParams.map(function (param) {\n      var splittedParam = param.split(\"=\");\n      if (\"queryId\" === splittedParam[0]) return splittedParam[1];\n    }).filter(function (q) {\n      return q;\n    }) : void 0;\n  return queryId && 0 < queryId.length ? event ? \"\".concat(event, \":/\").concat(queryId) : queryId[0] : isQuery ? origPath : void 0;\n}\nfunction setWatcher(firebase, dispatch, event, path, queryId) {\n  var id = queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path);\n  return firebase._.watchers[id] ? firebase._.watchers[id]++ : firebase._.watchers[id] = 1, dispatch({\n    type: _constants.actionTypes.SET_LISTENER,\n    path: path,\n    payload: {\n      id: id\n    }\n  }), firebase._.watchers[id];\n}\nfunction getWatcherCount(firebase, event, path, queryId) {\n  var id = queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path);\n  return firebase._.watchers[id];\n}\nfunction unsetWatcher(firebase, dispatch, event, path, queryId) {\n  var id = queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path);\n  path = path.split(\"#\")[0];\n  var watchers = firebase._.watchers;\n  1 >= watchers[id] ? (delete watchers[id], \"first_child\" !== event && \"once\" !== event && firebase.database().ref().child(path).off(event)) : watchers[id] && watchers[id]--, dispatch({\n    type: _constants.actionTypes.UNSET_LISTENER,\n    path: path,\n    payload: {\n      id: id\n    }\n  });\n}\nfunction applyParamsToQuery(queryParams, query) {\n  var doNotParse = !1;\n  return queryParams && queryParams.forEach(function (param) {\n    switch (param = param.split(\"=\"), param[0]) {\n      case \"orderByValue\":\n        query = query.orderByValue(), doNotParse = !0;\n        break;\n      case \"orderByPriority\":\n        query = query.orderByPriority(), doNotParse = !0;\n        break;\n      case \"orderByKey\":\n        query = query.orderByKey(), doNotParse = !0;\n        break;\n      case \"orderByChild\":\n        query = query.orderByChild(param[1]);\n        break;\n      case \"limitToFirst\":\n        query = query.limitToFirst(parseInt(param[1], 10));\n        break;\n      case \"limitToLast\":\n        query = query.limitToLast(parseInt(param[1], 10));\n        break;\n      case \"notParsed\":\n        doNotParse = !0;\n        break;\n      case \"parsed\":\n        doNotParse = !1;\n        break;\n      case \"equalTo\":\n        var equalToParam = doNotParse ? param[1] : tryParseToNumber(param[1]);\n        equalToParam = \"null\" === equalToParam ? null : equalToParam, equalToParam = \"false\" !== equalToParam && equalToParam, equalToParam = \"true\" === equalToParam || equalToParam, query = 3 === param.length ? query.equalTo(equalToParam, param[2]) : query.equalTo(equalToParam);\n        break;\n      case \"startAt\":\n        var startAtParam = doNotParse ? param[1] : tryParseToNumber(param[1]);\n        startAtParam = \"null\" === startAtParam ? null : startAtParam, query = 3 === param.length ? query.startAt(startAtParam, param[2]) : query.startAt(startAtParam);\n        break;\n      case \"endAt\":\n        var endAtParam = doNotParse ? param[1] : tryParseToNumber(param[1]);\n        endAtParam = \"null\" === endAtParam ? null : endAtParam, query = 3 === param.length ? query.endAt(endAtParam, param[2]) : query.endAt(endAtParam);\n    }\n  }), query;\n}\nfunction orderedFromSnapshot(snap) {\n  if (snap.hasChildren && !snap.hasChildren()) return null;\n  var ordered = [];\n  return snap.forEach && snap.forEach(function (child) {\n    ordered.push({\n      key: child.key,\n      value: child.val()\n    });\n  }), ordered.length ? ordered : null;\n}\nfunction populateAndDispatch(firebase, dispatch, config) {\n  var data = config.data,\n    populates = config.populates,\n    snapshot = config.snapshot,\n    path = config.path,\n    storeAs = config.storeAs;\n  return (0, _populate.promisesForPopulate)(firebase, snapshot.key, data, populates).then(function (results) {\n    return (0, _forEach2.default)(results, function (result, path) {\n      dispatch({\n        type: _constants.actionTypes.MERGE,\n        path: path,\n        data: result\n      });\n    }), dispatch({\n      type: _constants.actionTypes.SET,\n      path: storeAs || path,\n      data: data,\n      ordered: orderedFromSnapshot(snapshot)\n    }), results;\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.ERROR,\n      payload: err\n    }), Promise.reject(err);\n  });\n}","map":{"version":3,"sources":["../../src/utils/query.js"],"names":["tryParseToNumber","value","result","getWatchPath","event","path","Error","substring","getQueryIdFromPath","origPath","pathSplitted","split","isQuery","length","queryParams","queryId","map","param","splittedParam","filter","q","setWatcher","firebase","dispatch","id","_","watchers","type","actionTypes","SET_LISTENER","payload","getWatcherCount","unsetWatcher","database","ref","child","off","UNSET_LISTENER","applyParamsToQuery","query","doNotParse","forEach","orderByValue","orderByPriority","orderByKey","orderByChild","limitToFirst","parseInt","limitToLast","equalToParam","equalTo","startAtParam","startAt","endAtParam","endAt","orderedFromSnapshot","snap","hasChildren","ordered","push","key","val","populateAndDispatch","config","data","populates","snapshot","storeAs","then","results","MERGE","SET","catch","err","ERROR","Promise","reject"],"mappings":"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","sourcesContent":["import { actionTypes } from '../constants'\nimport { promisesForPopulate } from './populate'\nimport { isNaN, forEach } from 'lodash'\nimport { isString } from './index'\n\n/**\n * @private\n * @param {string|number} value - Item to attempt to parse to a number\n * @returns {any} Number if parse to number was successful, otherwise,\n * original value\n */\nfunction tryParseToNumber(value) {\n  const result = Number(value)\n  if (isNaN(result)) {\n    return value\n  }\n  return result\n}\n\n/**\n * @private\n * @param {string} event - Type of event to watch for\n * @param {string} path - Path to watch with watcher\n * @returns {string} watchPath\n */\nexport function getWatchPath(event, path) {\n  if (!event || event === '' || !path) {\n    throw new Error('Event and path are required')\n  }\n  return `${event}:${path.substring(0, 1) === '/' ? '' : '/'}${path}`\n}\n\n/**\n * @private\n * @param {string} path - Path from which to get query id\n * @param {string} event - Type of query event\n * @returns {string} Query id\n */\nexport function getQueryIdFromPath(path, event) {\n  if (!isString(path)) {\n    throw new Error('Query path must be a string')\n  }\n  const origPath = path\n  const pathSplitted = path.split('#')\n  path = pathSplitted[0]\n\n  const isQuery = pathSplitted.length > 1\n  const queryParams = isQuery ? pathSplitted[1].split('&') : []\n  const queryId = isQuery\n    ? queryParams\n        .map((param) => {\n          const splittedParam = param.split('=')\n          // Handle query id in path\n          if (splittedParam[0] === 'queryId') {\n            return splittedParam[1]\n          }\n        })\n        .filter((q) => q)\n    : undefined\n  return queryId && queryId.length > 0\n    ? event\n      ? `${event}:/${queryId}`\n      : queryId[0]\n    : isQuery\n    ? origPath\n    : undefined\n}\n\n/**\n * @private\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Redux dispatch function\n * @param {string} event - Type of event to watch for\n * @param {string} path - Path to watch with watcher\n * @param {string} queryId - Id of query\n * @returns {number} watcherCount - count\n */\nexport function setWatcher(firebase, dispatch, event, path, queryId) {\n  const id =\n    queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path)\n\n  if (firebase._.watchers[id]) {\n    firebase._.watchers[id]++\n  } else {\n    firebase._.watchers[id] = 1\n  }\n\n  dispatch({ type: actionTypes.SET_LISTENER, path, payload: { id } })\n\n  return firebase._.watchers[id]\n}\n\n/**\n * @private\n * @param {object} firebase - Internal firebase object\n * @param {string} event - Type of event to watch for\n * @param {string} path - Path to watch with watcher\n * @param {string} queryId - Id of query\n * @returns {number} watcherCount\n */\nexport function getWatcherCount(firebase, event, path, queryId) {\n  const id =\n    queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path)\n  return firebase._.watchers[id]\n}\n\n/**\n * @private\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Redux's dispatch function\n * @param {string} event - Type of event to watch for\n * @param {string} path - Path to watch with watcher\n * @param {string} queryId - Id of query\n */\nexport function unsetWatcher(firebase, dispatch, event, path, queryId) {\n  const id =\n    queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path)\n  path = path.split('#')[0]\n  const { watchers } = firebase._\n  if (watchers[id] <= 1) {\n    delete watchers[id]\n    if (event !== 'first_child' && event !== 'once') {\n      firebase.database().ref().child(path).off(event)\n    }\n  } else if (watchers[id]) {\n    watchers[id]--\n  }\n\n  dispatch({ type: actionTypes.UNSET_LISTENER, path, payload: { id } })\n}\n\n/**\n * Modify query to include methods based on query parameters (such\n * as orderByChild).\n * @param {Array} queryParams - Array of query parameters to apply to query\n * @param {object} query - Query object on which to apply query parameters\n * @returns {firebase.database.Query} Query with query params applied\n */\nexport function applyParamsToQuery(queryParams, query) {\n  let doNotParse = false\n  if (queryParams) {\n    queryParams.forEach((param) => {\n      param = param.split('=')\n      switch (param[0]) {\n        case 'orderByValue':\n          query = query.orderByValue()\n          doNotParse = true\n          break\n        case 'orderByPriority':\n          query = query.orderByPriority()\n          doNotParse = true\n          break\n        case 'orderByKey':\n          query = query.orderByKey()\n          doNotParse = true\n          break\n        case 'orderByChild':\n          query = query.orderByChild(param[1])\n          break\n        case 'limitToFirst':\n          // TODO: Handle number not being passed as param\n          query = query.limitToFirst(parseInt(param[1], 10))\n          break\n        case 'limitToLast':\n          // TODO: Handle number not being passed as param\n          query = query.limitToLast(parseInt(param[1], 10))\n          break\n        case 'notParsed':\n          // support disabling internal number parsing (number strings)\n          doNotParse = true\n          break\n        case 'parsed':\n          // support disabling internal number parsing (number strings)\n          doNotParse = false\n          break\n        case 'equalTo':\n          let equalToParam = !doNotParse ? tryParseToNumber(param[1]) : param[1] // eslint-disable-line no-case-declarations\n          equalToParam = equalToParam === 'null' ? null : equalToParam\n          equalToParam = equalToParam === 'false' ? false : equalToParam\n          equalToParam = equalToParam === 'true' ? true : equalToParam\n          query =\n            param.length === 3\n              ? query.equalTo(equalToParam, param[2])\n              : query.equalTo(equalToParam)\n          break\n        case 'startAt':\n          let startAtParam = !doNotParse ? tryParseToNumber(param[1]) : param[1] // eslint-disable-line no-case-declarations\n          startAtParam = startAtParam === 'null' ? null : startAtParam\n          query =\n            param.length === 3\n              ? query.startAt(startAtParam, param[2])\n              : query.startAt(startAtParam)\n          break\n        case 'endAt':\n          let endAtParam = !doNotParse ? tryParseToNumber(param[1]) : param[1] // eslint-disable-line no-case-declarations\n          endAtParam = endAtParam === 'null' ? null : endAtParam\n          query =\n            param.length === 3\n              ? query.endAt(endAtParam, param[2])\n              : query.endAt(endAtParam)\n          break\n      }\n    })\n  }\n\n  return query\n}\n\n/**\n * Get ordered array from snapshot\n * @param {firebase.database.DataSnapshot} snap - Data for which to create\n * an ordered array.\n * @returns {Array|null} Ordered list of children from snapshot or null\n */\nexport function orderedFromSnapshot(snap) {\n  if (snap.hasChildren && !snap.hasChildren()) {\n    return null\n  }\n  const ordered = []\n  if (snap.forEach) {\n    snap.forEach((child) => {\n      ordered.push({ key: child.key, value: child.val() })\n    })\n  }\n  return ordered.length ? ordered : null\n}\n\n/**\n * Get data associated with populate settings, and dispatch\n *\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Redux's dispatch function\n * @param {object} config - Config object\n * @param {any} config.data - Original query data result\n * @param {Array} config.populates - List of populate settings\n * @param {string} config.path - Base query path\n * @param {string} config.storeAs - Location within redux in which to\n * query results will be stored (path is used as default if not provided).\n * @returns {Promise} Promise that resolves after data for populates has been\n * loaded and associated actions have been dispatched\n * @private\n */\nexport function populateAndDispatch(firebase, dispatch, config) {\n  const { data, populates, snapshot, path, storeAs } = config\n  // TODO: Allow setting of unpopulated data before starting population through config\n  return promisesForPopulate(firebase, snapshot.key, data, populates)\n    .then((results) => {\n      // dispatch child sets first so isLoaded is only set to true for\n      // populatedDataToJS after all data is in redux (Issue #121)\n      // TODO: Allow config to toggle Combining into one SET action\n      // TODO: Set ordered for populate queries\n      forEach(results, (result, path) => {\n        dispatch({\n          type: actionTypes.MERGE,\n          path,\n          data: result\n        })\n      })\n      dispatch({\n        type: actionTypes.SET,\n        path: storeAs || path,\n        data,\n        ordered: orderedFromSnapshot(snapshot)\n      })\n      return results\n    })\n    .catch((err) => {\n      dispatch({\n        type: actionTypes.ERROR,\n        payload: err\n      })\n      return Promise.reject(err)\n    })\n}\n"]},"metadata":{},"sourceType":"script"}