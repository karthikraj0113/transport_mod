{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSnapshotByObject = getSnapshotByObject;\nexports.firestoreRef = firestoreRef;\nexports.getQueryName = getQueryName;\nexports.getBaseQueryName = getBaseQueryName;\nexports.listenerExists = listenerExists;\nexports.attachListener = attachListener;\nexports.detachListener = detachListener;\nexports.queryStrToObj = queryStrToObj;\nexports.getQueryConfig = getQueryConfig;\nexports.getQueryConfigs = getQueryConfigs;\nexports.orderedFromSnap = orderedFromSnap;\nexports.dataByIdSnapshot = dataByIdSnapshot;\nexports.getPopulateChild = getPopulateChild;\nexports.populateList = populateList;\nexports.promisesForPopulate = promisesForPopulate;\nexports.dispatchListenerResponse = dispatchListenerResponse;\nexports.getPopulateActions = getPopulateActions;\nexports.snapshotCache = void 0;\nvar _cloneDeep2 = _interopRequireDefault(require(\"lodash/cloneDeep\"));\nvar _set2 = _interopRequireDefault(require(\"lodash/set\"));\nvar _get2 = _interopRequireDefault(require(\"lodash/get\"));\nvar _map2 = _interopRequireDefault(require(\"lodash/map\"));\nvar _has2 = _interopRequireDefault(require(\"lodash/has\"));\nvar _forEach2 = _interopRequireDefault(require(\"lodash/forEach\"));\nvar _trim2 = _interopRequireDefault(require(\"lodash/trim\"));\nvar _isEmpty2 = _interopRequireDefault(require(\"lodash/isEmpty\"));\nvar _isNumber2 = _interopRequireDefault(require(\"lodash/isNumber\"));\nvar _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\nvar _constants = require(\"../constants\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nvar snapshotCache = new WeakMap();\nexports.snapshotCache = snapshotCache;\nfunction getSnapshotByObject(obj) {\n  return snapshotCache.get(obj);\n}\nfunction addWhereToRef(ref, where) {\n  if (!Array.isArray(where)) {\n    throw new Error('where parameter must be an array.');\n  }\n  if (Array.isArray(where[0])) {\n    return where.reduce(function (acc, whereArgs) {\n      return addWhereToRef(acc, whereArgs);\n    }, ref);\n  }\n  return ref.where.apply(ref, _toConsumableArray(where));\n}\nfunction addOrderByToRef(ref, orderBy) {\n  if (!Array.isArray(orderBy) && !(typeof orderBy === 'string' || orderBy instanceof String)) {\n    throw new Error('orderBy parameter must be an array or string.');\n  }\n  if (typeof orderBy === 'string' || orderBy instanceof String) {\n    return ref.orderBy(orderBy);\n  }\n  if (typeof orderBy[0] === 'string' || orderBy[0] instanceof String) {\n    return ref.orderBy.apply(ref, _toConsumableArray(orderBy));\n  }\n  return orderBy.reduce(function (acc, orderByArgs) {\n    return addOrderByToRef(acc, orderByArgs);\n  }, ref);\n}\nfunction arrayify(cursor) {\n  return [].concat(cursor);\n}\nfunction handleSubcollections(ref, subcollectionList) {\n  if (Array.isArray(subcollectionList)) {\n    subcollectionList.forEach(function (subcollection) {\n      if (subcollection.collection) {\n        if (typeof ref.collection !== 'function') {\n          throw new Error(\"Collection can only be run on a document. Check that query config for subcollection: \\\"\".concat(subcollection.collection, \"\\\" contains a doc parameter.\"));\n        }\n        ref = ref.collection(subcollection.collection);\n      }\n      if (subcollection.doc) ref = ref.doc(subcollection.doc);\n      if (subcollection.where) ref = addWhereToRef(ref, subcollection.where);\n      if (subcollection.orderBy) {\n        ref = addOrderByToRef(ref, subcollection.orderBy);\n      }\n      if (subcollection.limit) ref = ref.limit(subcollection.limit);\n      if (subcollection.startAt) {\n        var _ref;\n        ref = (_ref = ref).startAt.apply(_ref, _toConsumableArray(arrayify(subcollection.startAt)));\n      }\n      if (subcollection.startAfter) {\n        var _ref2;\n        ref = (_ref2 = ref).startAfter.apply(_ref2, _toConsumableArray(arrayify(subcollection.startAfter)));\n      }\n      if (subcollection.endAt) {\n        var _ref3;\n        ref = (_ref3 = ref).endAt.apply(_ref3, _toConsumableArray(arrayify(subcollection.endAt)));\n      }\n      if (subcollection.endBefore) {\n        var _ref4;\n        ref = (_ref4 = ref).endBefore.apply(_ref4, _toConsumableArray(arrayify(subcollection.endBefore)));\n      }\n      ref = handleSubcollections(ref, subcollection.subcollections);\n    });\n  }\n  return ref;\n}\nfunction firestoreRef(firebase, meta) {\n  var _ref5, _ref6, _ref7, _ref8;\n  if (!firebase.firestore) {\n    throw new Error('Firestore must be required and initalized.');\n  }\n  var collection = meta.collection,\n    collectionGroup = meta.collectionGroup,\n    doc = meta.doc,\n    subcollections = meta.subcollections,\n    where = meta.where,\n    orderBy = meta.orderBy,\n    limit = meta.limit,\n    startAt = meta.startAt,\n    startAfter = meta.startAfter,\n    endAt = meta.endAt,\n    endBefore = meta.endBefore;\n  var ref = firebase.firestore();\n  if (collection && collectionGroup) {\n    throw new Error('Reference cannot contain both Collection and CollectionGroup.');\n  }\n  if (collection) ref = ref.collection(collection);\n  if (collectionGroup) ref = ref.collectionGroup(collectionGroup);\n  if (doc) ref = ref.doc(doc);\n  ref = handleSubcollections(ref, subcollections);\n  if (where) ref = addWhereToRef(ref, where);\n  if (orderBy) ref = addOrderByToRef(ref, orderBy);\n  if (limit) ref = ref.limit(limit);\n  if (startAt) ref = (_ref5 = ref).startAt.apply(_ref5, _toConsumableArray(arrayify(startAt)));\n  if (startAfter) ref = (_ref6 = ref).startAfter.apply(_ref6, _toConsumableArray(arrayify(startAfter)));\n  if (endAt) ref = (_ref7 = ref).endAt.apply(_ref7, _toConsumableArray(arrayify(endAt)));\n  if (endBefore) ref = (_ref8 = ref).endBefore.apply(_ref8, _toConsumableArray(arrayify(endBefore)));\n  return ref;\n}\nfunction arrayToStr(key, value) {\n  if (typeof value === 'string' || value instanceof String || (0, _isNumber2.default)(value)) {\n    return \"\".concat(key, \"=\").concat(value);\n  }\n  if (typeof value[0] === 'string' || value[0] instanceof String) {\n    return \"\".concat(key, \"=\").concat(value.join(':'));\n  }\n  if (value && typeof value.toString === 'function') {\n    return \"\".concat(key, \"=\").concat(value.toString());\n  }\n  return value.map(function (val) {\n    return arrayToStr(key, val);\n  });\n}\nfunction pickQueryParams(obj) {\n  return ['where', 'orderBy', 'limit', 'startAfter', 'startAt', 'endAt', 'endBefore'].reduce(function (acc, key) {\n    return obj[key] ? _objectSpread({}, acc, _defineProperty({}, key, obj[key])) : acc;\n  }, {});\n}\nfunction serialize(queryParams) {\n  return Object.keys(queryParams).filter(function (key) {\n    return queryParams[key] !== undefined;\n  }).map(function (key) {\n    return arrayToStr(key, queryParams[key]);\n  }).join('&');\n}\nfunction getQueryName(meta) {\n  if (typeof meta === 'string' || meta instanceof String) {\n    return meta;\n  }\n  var collection = meta.collection,\n    collectionGroup = meta.collectionGroup,\n    doc = meta.doc,\n    subcollections = meta.subcollections,\n    storeAs = meta.storeAs,\n    remainingMeta = _objectWithoutProperties(meta, [\"collection\", \"collectionGroup\", \"doc\", \"subcollections\", \"storeAs\"]);\n  if (!collection && !collectionGroup) {\n    throw new Error('Collection or Collection Group is required to build query name');\n  }\n  if (storeAs) {\n    return storeAs;\n  }\n  var basePath = collection || collectionGroup;\n  if (doc) {\n    basePath = basePath.concat(\"/\".concat(doc));\n  }\n  if (collection && subcollections) {\n    console.error('Queries with subcollections must use \"storeAs\" to prevent invalid store updates. This closley matches the upcoming major release (v1), which stores subcollections at the top level by default.');\n    var mappedCollections = subcollections.map(function (subcollection) {\n      return getQueryName(subcollection);\n    });\n    basePath = \"\".concat(basePath, \"/\").concat(mappedCollections.join('/'));\n  }\n  var queryParams = pickQueryParams(remainingMeta);\n  if (!(0, _isEmpty2.default)(queryParams)) {\n    if (queryParams.where && !Array.isArray(queryParams.where)) {\n      throw new Error('where parameter must be an array.');\n    }\n    basePath = basePath.concat('?', serialize(queryParams));\n  }\n  return basePath;\n}\nfunction getBaseQueryName(meta) {\n  if (typeof meta === 'string' || meta instanceof String) {\n    return meta;\n  }\n  var collection = meta.collection,\n    collectionGroup = meta.collectionGroup,\n    subcollections = meta.subcollections,\n    remainingMeta = _objectWithoutProperties(meta, [\"collection\", \"collectionGroup\", \"subcollections\"]);\n  if (!collection && !collectionGroup) {\n    throw new Error('Collection or Collection Group is required to build query name');\n  }\n  var basePath = collection || collectionGroup;\n  if (collection && subcollections) {\n    var mappedCollections = subcollections.map(function (subcollection) {\n      return getQueryName(subcollection);\n    });\n    basePath = \"\".concat(basePath, \"/\").concat(mappedCollections.join('/'));\n  }\n  var queryParams = pickQueryParams(remainingMeta);\n  if (!(0, _isEmpty2.default)(queryParams)) {\n    if (queryParams.where && !Array.isArray(queryParams.where)) {\n      throw new Error('where parameter must be an array.');\n    }\n    basePath = basePath.concat('?', serialize(queryParams));\n  }\n  return basePath;\n}\nfunction confirmMetaAndConfig(firebase, meta) {\n  if (!meta) {\n    throw new Error('Meta data is required to attach listener.');\n  }\n  if (!firebase || !firebase._ || !firebase._.listeners) {\n    throw new Error('Internal Firebase object required to attach listener. Confirm that reduxFirestore enhancer was added when you were creating your store');\n  }\n}\nfunction listenerExists(firebase, meta) {\n  confirmMetaAndConfig(firebase, meta);\n  var name = getQueryName(meta);\n  return !!firebase._.listeners[name];\n}\nfunction attachListener(firebase, dispatch, meta, unsubscribe) {\n  confirmMetaAndConfig(firebase, meta);\n  var name = getQueryName(meta);\n  if (!firebase._.listeners[name]) {\n    firebase._.listeners[name] = unsubscribe;\n  }\n  dispatch({\n    type: _constants.actionTypes.SET_LISTENER,\n    meta: meta,\n    payload: {\n      name: name\n    }\n  });\n  return firebase._.listeners;\n}\nfunction detachListener(firebase, dispatch, meta) {\n  var name = getQueryName(meta);\n  if (firebase._.listeners[name]) {\n    firebase._.listeners[name]();\n    delete firebase._.listeners[name];\n  }\n  dispatch({\n    type: _constants.actionTypes.UNSET_LISTENER,\n    meta: meta,\n    payload: {\n      name: name\n    }\n  });\n}\nfunction queryStrToObj(queryPathStr, parsedPath) {\n  var pathArr = parsedPath || (0, _trim2.default)(queryPathStr, ['/']).split('/');\n  var _pathArr = _toArray(pathArr),\n    collection = _pathArr[0],\n    doc = _pathArr[1],\n    subcollections = _pathArr.slice(2);\n  var queryObj = {};\n  if (collection) queryObj.collection = collection;\n  if (doc) queryObj.doc = doc;\n  if (subcollections.length) {\n    queryObj.subcollections = [queryStrToObj('', subcollections)];\n  }\n  return queryObj;\n}\nfunction getQueryConfig(query) {\n  if (typeof query === 'string' || query instanceof String) {\n    return queryStrToObj(query);\n  }\n  if ((0, _isObject2.default)(query)) {\n    if (!query.collection && !query.collectionGroup && !query.doc) {\n      throw new Error('Collection, Collection Group and/or Doc are required parameters within query definition object.');\n    }\n    return query;\n  }\n  throw new Error('Invalid Path Definition: Only Strings and Objects are accepted.');\n}\nfunction getQueryConfigs(queries) {\n  if (Array.isArray(queries)) {\n    return queries.map(getQueryConfig);\n  }\n  if (typeof queries === 'string' || queries instanceof String) {\n    return queryStrToObj(queries);\n  }\n  if ((0, _isObject2.default)(queries)) {\n    return [getQueryConfig(queries)];\n  }\n  throw new Error('Querie(s) must be an Array or a string.');\n}\nfunction orderedFromSnap(snap) {\n  var ordered = [];\n  if (snap.data && snap.exists) {\n    var obj = (0, _isObject2.default)(snap.data()) ? _objectSpread({\n      id: snap.id\n    }, snap.data() || snap.data) : {\n      id: snap.id,\n      data: snap.data()\n    };\n    snapshotCache.set(obj, snap);\n    ordered.push(obj);\n  } else if (snap.forEach) {\n    snap.forEach(function (doc) {\n      var obj = (0, _isObject2.default)(doc.data()) ? _objectSpread({\n        id: doc.id\n      }, doc.data() || doc.data) : {\n        id: doc.id,\n        data: doc.data()\n      };\n      snapshotCache.set(obj, doc);\n      ordered.push(obj);\n    });\n  }\n  snapshotCache.set(ordered, snap);\n  return ordered;\n}\nfunction dataByIdSnapshot(snap) {\n  var data = {};\n  if (snap.data) {\n    var snapData = snap.exists ? snap.data() : null;\n    if (snapData) {\n      snapshotCache.set(snapData, snap);\n    }\n    data[snap.id] = snapData;\n  } else if (snap.forEach) {\n    snap.forEach(function (doc) {\n      var snapData = doc.data() || doc;\n      snapshotCache.set(snapData, doc);\n      data[doc.id] = snapData;\n    });\n  }\n  if (!!data && Object.keys(data).length) {\n    snapshotCache.set(data, snap);\n    return data;\n  }\n  return null;\n}\nfunction getPopulateChild(firebase, populate, id) {\n  return firestoreRef(firebase, {\n    collection: populate.root,\n    doc: id\n  }).get().then(function (snap) {\n    return _objectSpread({\n      id: id\n    }, snap.data());\n  });\n}\nfunction populateList(firebase, originalObj, p, results) {\n  if (!results[p.root]) {\n    (0, _set2.default)(results, p.root, {});\n  }\n  return Promise.all((0, _map2.default)(originalObj, function (id, childKey) {\n    var populateKey = id === true || p.populateByKey ? childKey : id;\n    return getPopulateChild(firebase, p, populateKey).then(function (pc) {\n      if (pc) {\n        return (0, _set2.default)(results, \"\".concat(p.root, \".\").concat(populateKey), pc);\n      }\n      return results;\n    });\n  }));\n}\nfunction getPopulateObj(str) {\n  if (typeof str === 'string' || str instanceof String) {\n    return str;\n  }\n  var strArray = str.split(':');\n  return {\n    child: strArray[0],\n    root: strArray[1]\n  };\n}\nfunction getPopulateObjs(arr) {\n  if (!Array.isArray(arr)) {\n    return arr;\n  }\n  return arr.map(function (o) {\n    return (0, _isObject2.default)(o) ? o : getPopulateObj(o);\n  });\n}\nfunction promisesForPopulate(firebase, dataKey, originalData, populatesIn) {\n  var promisesArray = [];\n  var results = {};\n  var populatesForData = getPopulateObjs(typeof populatesIn === 'function' ? populatesIn(dataKey, originalData) : populatesIn);\n  var dataHasPopulateChilds = populatesForData.some(function (populate) {\n    return (0, _has2.default)(originalData, populate.child);\n  });\n  if (dataHasPopulateChilds) {\n    populatesForData.forEach(function (p) {\n      var childDataVal = (0, _get2.default)(originalData, p.child);\n      if (typeof childDataVal === 'string' || childDataVal instanceof String) {\n        return promisesArray.push(getPopulateChild(firebase, p, childDataVal).then(function (v) {\n          if (v) {\n            (0, _set2.default)(results, \"\".concat(p.storeAs ? p.storeAs : p.root, \".\").concat(childDataVal), v);\n          }\n        }));\n      }\n      return promisesArray.push(populateList(firebase, childDataVal, p, results));\n    });\n  } else {\n    (0, _forEach2.default)(originalData, function (d, key) {\n      var populatesForDataItem = getPopulateObjs(typeof populatesIn === 'function' ? populatesIn(key, d) : populatesIn);\n      (0, _forEach2.default)(populatesForDataItem, function (p) {\n        var idOrList = (0, _get2.default)(d, p.child);\n        if (!idOrList) {\n          return;\n        }\n        if (typeof idOrList === 'string' || idOrList instanceof String) {\n          return promisesArray.push(getPopulateChild(firebase, p, idOrList).then(function (v) {\n            if (v) {\n              (0, _set2.default)(results, \"\".concat(p.storeAs ? p.storeAs : p.root, \".\").concat(idOrList), v);\n            }\n            return results;\n          }));\n        }\n        if (Array.isArray(idOrList) || (0, _isObject2.default)(idOrList)) {\n          return promisesArray.push(populateList(firebase, idOrList, p, results));\n        }\n      });\n    });\n  }\n  return Promise.all(promisesArray).then(function () {\n    return results;\n  });\n}\nvar changeTypeToEventType = {\n  added: _constants.actionTypes.DOCUMENT_ADDED,\n  removed: _constants.actionTypes.DOCUMENT_REMOVED,\n  modified: _constants.actionTypes.DOCUMENT_MODIFIED\n};\nfunction docChangeEvent(change) {\n  var originalMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var meta = _objectSpread({}, (0, _cloneDeep2.default)(originalMeta), {\n    path: change.doc.ref.path\n  });\n  if (originalMeta.subcollections && !originalMeta.storeAs) {\n    meta.subcollections[0] = _objectSpread({}, meta.subcollections[0], {\n      doc: change.doc.id\n    });\n  } else {\n    meta.doc = change.doc.id;\n  }\n  return {\n    type: changeTypeToEventType[change.type] || _constants.actionTypes.DOCUMENT_MODIFIED,\n    meta: meta,\n    payload: {\n      data: change.doc.data(),\n      ordered: {\n        oldIndex: change.oldIndex,\n        newIndex: change.newIndex\n      }\n    }\n  };\n}\nfunction dispatchListenerResponse(_ref9) {\n  var dispatch = _ref9.dispatch,\n    docData = _ref9.docData,\n    meta = _ref9.meta,\n    firebase = _ref9.firebase;\n  var _ref10 = firebase._.config || {},\n    mergeOrdered = _ref10.mergeOrdered,\n    mergeOrderedDocUpdates = _ref10.mergeOrderedDocUpdates,\n    mergeOrderedCollectionUpdates = _ref10.mergeOrderedCollectionUpdates;\n  var docChanges = typeof docData.docChanges === 'function' ? docData.docChanges() : docData.docChanges;\n  if (docChanges && docChanges.length < docData.size) {\n    docChanges.forEach(function (change) {\n      dispatch(docChangeEvent(change, meta));\n    });\n  } else {\n    dispatch({\n      type: _constants.actionTypes.LISTENER_RESPONSE,\n      meta: meta,\n      payload: {\n        data: dataByIdSnapshot(docData),\n        ordered: orderedFromSnap(docData)\n      },\n      merge: {\n        docs: mergeOrdered && mergeOrderedDocUpdates,\n        collections: mergeOrdered && mergeOrderedCollectionUpdates\n      }\n    });\n  }\n}\nfunction getPopulateActions(_ref11) {\n  var firebase = _ref11.firebase,\n    docData = _ref11.docData,\n    meta = _ref11.meta;\n  return promisesForPopulate(firebase, docData.id, dataByIdSnapshot(docData), meta.populates).then(function (populateResults) {\n    return Object.keys(populateResults).map(function (resultKey) {\n      return {\n        meta: {\n          collection: resultKey\n        },\n        payload: {\n          data: populateResults[resultKey]\n        },\n        requesting: false,\n        requested: true\n      };\n    });\n  }).catch(function (populateErr) {\n    console.error('Error with populate:', populateErr, meta);\n    return Promise.reject(populateErr);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}