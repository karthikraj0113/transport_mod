{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.remove = remove, exports.unWatchEvent = unWatchEvent, exports.unWatchEvents = unWatchEvents, exports.watchEvent = watchEvent, exports.watchEvents = watchEvents;\nvar _constants = require(\"../constants\"),\n  _query = require(\"../utils/query\");\nfunction watchEvent(firebase, dispatch, options) {\n  if (!firebase.database || \"function\" != typeof firebase.database) throw new Error(\"Firebase database is required to create watchers\");\n  var type = options.type,\n    path = options.path,\n    populates = options.populates,\n    queryParams = options.queryParams,\n    queryId = options.queryId,\n    isQuery = options.isQuery,\n    storeAs = options.storeAs,\n    logErrors = firebase._.config.logErrors,\n    watchPath = storeAs ? \"\".concat(path, \"@\").concat(storeAs) : path,\n    id = queryId || (0, _query.getQueryIdFromPath)(path),\n    counter = (0, _query.getWatcherCount)(firebase, type, watchPath, id);\n  if (0 < counter && id && (0, _query.unsetWatcher)(firebase, dispatch, type, path, id), (0, _query.setWatcher)(firebase, dispatch, type, watchPath, id), !(0 < counter)) {\n    if (\"first_child\" === type) return firebase.database().ref().child(path).orderByKey().limitToFirst(1).once(\"value\").then(function (snapshot) {\n      return null === snapshot.val() && dispatch({\n        type: _constants.actionTypes.NO_VALUE,\n        path: storeAs || path\n      }), snapshot;\n    }).catch(function (err) {\n      return dispatch({\n        type: _constants.actionTypes.ERROR,\n        path: storeAs || path,\n        payload: err\n      }), Promise.reject(err);\n    });\n    var query = firebase.database().ref().child(path);\n    return isQuery && (query = (0, _query.applyParamsToQuery)(queryParams, query)), dispatch({\n      type: _constants.actionTypes.START,\n      path: storeAs || path\n    }), \"once\" === type ? query.once(\"value\").then(function (snapshot) {\n      return null === snapshot.val() ? dispatch({\n        type: _constants.actionTypes.NO_VALUE,\n        path: storeAs || path\n      }) : populates ? (0, _query.populateAndDispatch)(firebase, dispatch, {\n        path: path,\n        storeAs: storeAs,\n        snapshot: snapshot,\n        data: snapshot.val(),\n        populates: populates\n      }) : dispatch({\n        type: _constants.actionTypes.SET,\n        path: storeAs || path,\n        data: snapshot.val(),\n        ordered: (0, _query.orderedFromSnapshot)(snapshot)\n      });\n    }).catch(function (err) {\n      return dispatch({\n        type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n        payload: err\n      }), Promise.reject(err);\n    }) : void query.on(type, function (snapshot) {\n      var data = \"child_removed\" === type ? void 0 : snapshot.val(),\n        resultPath = storeAs || \"value\" === type ? path : \"\".concat(path, \"/\").concat(snapshot.key);\n      if (!populates) {\n        var ordered = \"child_added\" === type ? [{\n          key: snapshot.key,\n          value: snapshot.val()\n        }] : (0, _query.orderedFromSnapshot)(snapshot);\n        return dispatch({\n          type: _constants.actionTypes.SET,\n          path: storeAs || resultPath,\n          data: data,\n          ordered: ordered\n        });\n      }\n      return (0, _query.populateAndDispatch)(firebase, dispatch, {\n        path: path,\n        storeAs: storeAs,\n        snapshot: snapshot,\n        data: snapshot.val(),\n        populates: populates\n      });\n    }, function (err) {\n      logErrors && console.log(\"Error retrieving data for path: \".concat(path, \", storeAs: \").concat(storeAs, \". Firebase:\"), err), dispatch({\n        type: _constants.actionTypes.ERROR,\n        storeAs: storeAs,\n        path: path,\n        payload: err\n      });\n    });\n  }\n}\nfunction unWatchEvent(firebase, dispatch, _ref) {\n  var type = _ref.type,\n    path = _ref.path,\n    storeAs = _ref.storeAs,\n    queryId = _ref.queryId,\n    watchPath = storeAs ? \"\".concat(path, \"@\").concat(storeAs) : path;\n  (0, _query.unsetWatcher)(firebase, dispatch, type, watchPath, queryId);\n}\nfunction watchEvents(firebase, dispatch, events) {\n  if (!Array.isArray(events)) throw new Error(\"Events config must be an Array\");\n  return events.map(function (event) {\n    return watchEvent(firebase, dispatch, event);\n  });\n}\nfunction unWatchEvents(firebase, dispatch, events) {\n  null === events || void 0 === events ? void 0 : events.forEach(function (event) {\n    return unWatchEvent(firebase, dispatch, event);\n  });\n}\nfunction remove(firebase, dispatch, path) {\n  var options = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : {},\n    _options$dispatchActi = options.dispatchAction,\n    dispatchRemoveAction = firebase._.config.dispatchRemoveAction;\n  return firebase.database().ref(path).remove().then(function () {\n    return dispatchRemoveAction && (!(void 0 !== _options$dispatchActi) || _options$dispatchActi) && dispatch({\n      type: _constants.actionTypes.REMOVE,\n      path: path\n    }), path;\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.ERROR,\n      payload: err\n    }), Promise.reject(err);\n  });\n}","map":{"version":3,"sources":["../../src/actions/query.js"],"names":["watchEvent","firebase","dispatch","options","database","Error","type","path","populates","queryParams","queryId","isQuery","storeAs","config","logErrors","_","watchPath","id","counter","ref","child","orderByKey","limitToFirst","once","then","snapshot","val","actionTypes","NO_VALUE","catch","err","ERROR","payload","Promise","reject","query","START","SET","data","ordered","UNAUTHORIZED_ERROR","on","resultPath","key","value","console","log","unWatchEvent","watchEvents","events","Array","isArray","map","event","unWatchEvents","forEach","remove","dispatchAction","dispatchRemoveAction","REMOVE"],"mappings":";;;;;;;AAwBO,SAASA,UAAT,CAAoBC,QAApB,EAA8BC,QAA9B,EAAwCC,OAAxC,EAAiD;EACtD,IAAI,CAACF,QAAQ,CAACG,QAAV,IAAmD,UAA7B,IAAA,OAAOH,QAAQ,CAACG,QAA1C,EACE,MAAM,IAAIC,KAAJ,CAAU,kDAAV,CAAN;EAFoD,IAKpDC,IALoD,GAYlDH,OAZkD,CAKpDG,IALoD;IAMpDC,IANoD,GAYlDJ,OAZkD,CAMpDI,IANoD;IAOpDC,SAPoD,GAYlDL,OAZkD,CAOpDK,SAPoD;IAQpDC,WARoD,GAYlDN,OAZkD,CAQpDM,WARoD;IASpDC,OAToD,GAYlDP,OAZkD,CASpDO,OAToD;IAUpDC,OAVoD,GAYlDR,OAZkD,CAUpDQ,OAVoD;IAWpDC,OAXoD,GAYlDT,OAZkD,CAWpDS,OAXoD;IAc1CE,SAd0C,GAelDb,QAAQ,CAACc,CAfyC,CAcpDF,MAdoD,CAc1CC,SAd0C;IAiBhDE,SAAS,GAAIJ,OAAD,GAAA,EAAA,CAAA,MAAA,CAAqBL,IAArB,EAAA,GAAA,CAAA,CAAA,MAAA,CAA6BK,OAA7B,CAAA,GAAWL,IAjByB;IAkBhDU,EAAE,GAAGP,OAAO,IAAI,CAAA,CAAA,EAAA,MAAA,CAAA,kBAAA,EAAmBH,IAAnB,CAlBgC;IAmBhDW,OAAO,GAAG,CAAA,CAAA,EAAA,MAAA,CAAA,eAAA,EAAgBjB,QAAhB,EAA0BK,IAA1B,EAAgCU,SAAhC,EAA2CC,EAA3C,CAnBsC;EA6BtD,IARc,CAAV,GAAA,OAQJ,IAPMA,EAON,IANI,CAAA,CAAA,EAAA,MAAA,CAAA,YAAA,EAAahB,QAAb,EAAuBC,QAAvB,EAAiCI,IAAjC,EAAuCC,IAAvC,EAA6CU,EAA7C,CAMJ,EAFA,CAAA,CAAA,EAAA,MAAA,CAAA,UAAA,EAAWhB,QAAX,EAAqBC,QAArB,EAA+BI,IAA/B,EAAqCU,SAArC,EAAgDC,EAAhD,CAEA,EAAA,EAAc,CAAV,GAAA,OAAJ,CAAA,EAAA;IAIA,IAAa,aAAT,KAAA,IAAJ,EACE,OAAOhB,QAAQ,CACZG,QADIH,CAAAA,CAAAA,CAEJkB,GAFIlB,CAAAA,CAAAA,CAGJmB,KAHInB,CAGEM,IAHFN,CAAAA,CAIJoB,UAJIpB,CAAAA,CAAAA,CAKJqB,YALIrB,CAKS,CALTA,CAAAA,CAMJsB,IANItB,CAMC,OANDA,CAAAA,CAOJuB,IAPIvB,CAOC,UAACwB,QAAD,EAAc;MACK,OAAA,IAAnB,KAAA,QAAQ,CAACC,GAAT,CAAA,CAMJ,IALExB,QAAQ,CAAC;QACPI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYC,QADX;QAEPrB,IAAI,EAAEK,OAAO,IAAIL;MAFV,CAAD,CAKV,EAAOkB,QACR;IAAA,CAfIxB,CAAAA,CAgBJ4B,KAhBI5B,CAgBE,UAAC6B,GAAD,EAAS;MACd5B,OAAAA,QAAQ,CAAC;QACPI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYI,KADX;QAEPxB,IAAI,EAAEK,OAAO,IAAIL,IAFV;QAGPyB,OAAO,EAAEF;MAHF,CAAD,CAKR,EAAOG,OAAO,CAACC,MAARD,CAAeH,GAAfG,CACR;IAAA,CAvBIhC,CAAP;IA0BF,IAAIkC,KAAK,GAAGlC,QAAQ,CAACG,QAATH,CAAAA,CAAAA,CAAoBkB,GAApBlB,CAAAA,CAAAA,CAA0BmB,KAA1BnB,CAAgCM,IAAhCN,CAAZ;IA/BA,OAiCIU,OAjCJ,KAkCEwB,KAAK,GAAG,CAAA,CAAA,EAAA,MAAA,CAAA,kBAAA,EAAmB1B,WAAnB,EAAgC0B,KAAhC,CAlCV,CAAA,EAqCAjC,QAAQ,CAAC;MAAEI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYS,KAApB;MAA2B7B,IAAI,EAAEK,OAAO,IAAIL;IAA5C,CAAD,CArCR,EAwCa,MAAT,KAAA,IAxCJ,GAyCS4B,KAAK,CACTZ,IADIY,CACC,OADDA,CAAAA,CAEJX,IAFIW,CAEC,UAACV,QAAD,EAAc;MAAA,OACK,IAAnB,KAAA,QAAQ,CAACC,GAAT,CAAA,CADc,GAETxB,QAAQ,CAAC;QACdI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYC,QADJ;QAEdrB,IAAI,EAAEK,OAAO,IAAIL;MAFH,CAAD,CAFC,GAQbC,SARa,GAkBX,CAAA,CAAA,EAAA,MAAA,CAAA,mBAAA,EAAoBP,QAApB,EAA8BC,QAA9B,EAAwC;QAC7CK,IAAI,EAAJA,IAD6C;QAE7CK,OAAO,EAAPA,OAF6C;QAG7Ca,QAAQ,EAARA,QAH6C;QAI7Ca,IAAI,EAAEb,QAAQ,CAACC,GAATD,CAAAA,CAJuC;QAK7CjB,SAAS,EAATA;MAL6C,CAAxC,CAlBW,GAUTN,QAAQ,CAAC;QACdI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYU,GADJ;QAEd9B,IAAI,EAAEK,OAAO,IAAIL,IAFH;QAGd+B,IAAI,EAAEb,QAAQ,CAACC,GAATD,CAAAA,CAHQ;QAIdc,OAAO,EAAE,CAAA,CAAA,EAAA,MAAA,CAAA,mBAAA,EAAoBd,QAApB;MAJK,CAAD,CAelB;IAAA,CA3BIU,CAAAA,CA4BJN,KA5BIM,CA4BE,UAACL,GAAD,EAAS;MACd5B,OAAAA,QAAQ,CAAC;QACPI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYa,kBADX;QAEPR,OAAO,EAAEF;MAFF,CAAD,CAIR,EAAOG,OAAO,CAACC,MAARD,CAAeH,GAAfG,CACR;IAAA,CAlCIE,CAzCT,GAAA,KAgFAA,KAAK,CAACM,EAANN,CACE7B,IADF6B,EAEE,UAACV,QAAD,EAAc;MAAA,IACNa,IAAI,GAAY,eAAT,KAAA,IAAI,GAAA,KAAA,CAAA,GAAmCb,QAAQ,CAACC,GAATD,CAAAA,CADxC;QAENiB,UAAU,GACd9B,OAAO,IAAa,OAAT,KAAA,IAAXA,GAA8BL,IAA9BK,GAAAA,EAAAA,CAAAA,MAAAA,CAAwCL,IAAxCK,EAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAgDa,QAAQ,CAACkB,GAAzD/B,CAHU;MAMZ,IAAI,CAACJ,SAAL,EAAgB;QAEd,IAAM+B,OAAO,GACF,aAAT,KAAA,IAAI,GACA,CAAC;UAAEI,GAAG,EAAElB,QAAQ,CAACkB,GAAhB;UAAqBC,KAAK,EAAEnB,QAAQ,CAACC,GAATD,CAAAA;QAA5B,CAAD,CADA,GAEA,CAAA,CAAA,EAAA,MAAA,CAAA,mBAAA,EAAoBA,QAApB,CAHN;QAIA,OAAOvB,QAAQ,CAAC;UACdI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYU,GADJ;UAEd9B,IAAI,EAAEK,OAAO,IAAI8B,UAFH;UAGdJ,IAAI,EAAJA,IAHc;UAIdC,OAAO,EAAPA;QAJc,CAAD,CAMhB;MAAA;MAED,OAAO,CAAA,CAAA,EAAA,MAAA,CAAA,mBAAA,EAAoBtC,QAApB,EAA8BC,QAA9B,EAAwC;QAC7CK,IAAI,EAAJA,IAD6C;QAE7CK,OAAO,EAAPA,OAF6C;QAG7Ca,QAAQ,EAARA,QAH6C;QAI7Ca,IAAI,EAAEb,QAAQ,CAACC,GAATD,CAAAA,CAJuC;QAK7CjB,SAAS,EAATA;MAL6C,CAAxC,CAOR;IAAA,CA7BH2B,EA8BE,UAACL,GAAD,EAAS;MACHhB,SADG,IAGL+B,OAAO,CAACC,GAARD,CAAAA,kCAAAA,CAAAA,MAAAA,CACqCtC,IADrCsC,EAAAA,aAAAA,CAAAA,CAAAA,MAAAA,CACuDjC,OADvDiC,EAAAA,aAAAA,CAAAA,EAEEf,GAFFe,CAHK,EAQP3C,QAAQ,CAAC;QACPI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYI,KADX;QAEPnB,OAAO,EAAPA,OAFO;QAGPL,IAAI,EAAJA,IAHO;QAIPyB,OAAO,EAAEF;MAJF,CAAD,CAMT;IAAA,CA5CHK,CAhFA;EAAA;AA8HD;AAeM,SAASY,YAAT,CACL9C,QADK,EAELC,QAFK,EAAA,IAAA,EAIL;EADEI,IAAAA,IACF,GAAA,IAAA,CADEA,IACF;IADQC,IACR,GAAA,IAAA,CADQA,IACR;IADcK,OACd,GAAA,IAAA,CADcA,OACd;IADuBF,OACvB,GAAA,IAAA,CADuBA,OACvB;IACMM,SAAS,GAAIJ,OAAD,GAAA,EAAA,CAAA,MAAA,CAAqBL,IAArB,EAAA,GAAA,CAAA,CAAA,MAAA,CAA6BK,OAA7B,CAAA,GAAWL,IAD7B;EAEA,CAAA,CAAA,EAAA,MAAA,CAAA,YAAA,EAAaN,QAAb,EAAuBC,QAAvB,EAAiCI,IAAjC,EAAuCU,SAAvC,EAAkDN,OAAlD,CACD;AAAA;AASM,SAASsC,WAAT,CAAqB/C,QAArB,EAA+BC,QAA/B,EAAyC+C,MAAzC,EAAiD;EACtD,IAAI,CAACC,KAAK,CAACC,OAAND,CAAcD,MAAdC,CAAL,EACE,MAAM,IAAI7C,KAAJ,CAAU,gCAAV,CAAN;EAEF,OAAO4C,MAAM,CAACG,GAAPH,CAAW,UAACI,KAAD,EAAA;IAAA,OAAWrD,UAAU,CAACC,QAAD,EAAWC,QAAX,EAAqBmD,KAArB,CAArB;EAAA,CAAXJ,CACR;AAAA;AAQM,SAASK,aAAT,CAAuBrD,QAAvB,EAAiCC,QAAjC,EAA2C+C,MAA3C,EAAmD;EAAA,IAAA,KACxDA,MADwD,IAAA,KAAA,CAAA,KACxDA,MADwD,GAAA,KAAA,CAAA,GACxDA,MAAM,CAAEM,OAARN,CAAgB,UAACI,KAAD,EAAA;IAAA,OAAWN,YAAY,CAAC9C,QAAD,EAAWC,QAAX,EAAqBmD,KAArB,CAAvB;EAAA,CAAhBJ,CACD;AAAA;AAYM,SAASO,MAAT,CAAgBvD,QAAhB,EAA0BC,QAA1B,EAAoCK,IAApC,EAAwD;EAAdJ,IAAAA,OAAc,GAAA,CAAA,GAAA,SAAA,CAAA,MAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,KAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;IAAA,qBAAA,GAC3BA,OAD2B,CACrDsD,cADqD;IAErDC,oBAFqD,GAE5BzD,QAAQ,CAACc,CAATd,CAAWY,MAFiB,CAErD6C,oBAFqD;EAG7D,OAAOzD,QAAQ,CACZG,QADIH,CAAAA,CAAAA,CAEJkB,GAFIlB,CAEAM,IAFAN,CAAAA,CAGJuD,MAHIvD,CAAAA,CAAAA,CAIJuB,IAJIvB,CAIC,YAAM;IACNyD,OAAAA,oBAAoB,KAAA,EAAA,KAAA,CAAA,KAAA,qBAAA,CAAA,IAAA,qBAAA,CAGxB,IAFExD,QAAQ,CAAC;MAAEI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYgC,MAApB;MAA4BpD,IAAI,EAAJA;IAA5B,CAAD,CAEV,EAAOA,IACR;EAAA,CATIN,CAAAA,CAUJ4B,KAVI5B,CAUE,UAAC6B,GAAD,EAAS;IACd5B,OAAAA,QAAQ,CAAC;MAAEI,IAAI,EAAEqB,UAAAA,CAAAA,WAAAA,CAAYI,KAApB;MAA2BC,OAAO,EAAEF;IAApC,CAAD,CACR,EAAOG,OAAO,CAACC,MAARD,CAAeH,GAAfG,CACR;EAAA,CAbIhC,CAcR;AAAA","sourcesContent":["import { actionTypes } from '../constants'\nimport {\n  orderedFromSnapshot,\n  populateAndDispatch,\n  applyParamsToQuery,\n  getWatcherCount,\n  setWatcher,\n  unsetWatcher,\n  getQueryIdFromPath\n} from '../utils/query'\n\n/**\n * Watch a path in Firebase Real Time Database\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {object} options - Event options object\n * @param {string} options.type - Type of event to watch for (defaults to value)\n * @param {string} options.path - Path to watch with watcher\n * @param {Array} options.queryParams - List of parameters for the query\n * @param {string} options.queryId - id of the query\n * @param {boolean} options.isQuery - id of the query\n * @param {string} options.storeAs - Location within redux to store value\n * @returns {Promise|void} Returns promise if query is a promise\n */\nexport function watchEvent(firebase, dispatch, options) {\n  if (!firebase.database || typeof firebase.database !== 'function') {\n    throw new Error('Firebase database is required to create watchers')\n  }\n  const {\n    type,\n    path,\n    populates,\n    queryParams,\n    queryId,\n    isQuery,\n    storeAs\n  } = options\n  const {\n    config: { logErrors }\n  } = firebase._\n\n  const watchPath = !storeAs ? path : `${path}@${storeAs}`\n  const id = queryId || getQueryIdFromPath(path)\n  const counter = getWatcherCount(firebase, type, watchPath, id)\n\n  if (counter > 0) {\n    if (id) {\n      unsetWatcher(firebase, dispatch, type, path, id)\n    }\n  }\n\n  setWatcher(firebase, dispatch, type, watchPath, id)\n\n  if (counter > 0) {\n    return\n  }\n\n  if (type === 'first_child') {\n    return firebase\n      .database()\n      .ref()\n      .child(path)\n      .orderByKey()\n      .limitToFirst(1)\n      .once('value')\n      .then((snapshot) => {\n        if (snapshot.val() === null) {\n          dispatch({\n            type: actionTypes.NO_VALUE,\n            path: storeAs || path\n          })\n        }\n        return snapshot\n      })\n      .catch((err) => {\n        dispatch({\n          type: actionTypes.ERROR,\n          path: storeAs || path,\n          payload: err\n        })\n        return Promise.reject(err)\n      })\n  }\n\n  let query = firebase.database().ref().child(path)\n\n  if (isQuery) {\n    query = applyParamsToQuery(queryParams, query)\n  }\n\n  dispatch({ type: actionTypes.START, path: storeAs || path })\n\n  // Handle once queries\n  if (type === 'once') {\n    return query\n      .once('value')\n      .then((snapshot) => {\n        if (snapshot.val() === null) {\n          return dispatch({\n            type: actionTypes.NO_VALUE,\n            path: storeAs || path\n          })\n        }\n        // dispatch normal event if no populates exist\n        if (!populates) {\n          // create an array for preserving order of children under ordered\n          return dispatch({\n            type: actionTypes.SET,\n            path: storeAs || path,\n            data: snapshot.val(),\n            ordered: orderedFromSnapshot(snapshot)\n          })\n        }\n        // populate and dispatch associated actions if populates exist\n        return populateAndDispatch(firebase, dispatch, {\n          path,\n          storeAs,\n          snapshot,\n          data: snapshot.val(),\n          populates\n        })\n      })\n      .catch((err) => {\n        dispatch({\n          type: actionTypes.UNAUTHORIZED_ERROR,\n          payload: err\n        })\n        return Promise.reject(err)\n      })\n  }\n  // Handle all other queries\n\n  /* istanbul ignore next: is run by tests but doesn't show in coverage */\n  query.on(\n    type,\n    (snapshot) => {\n      const data = type === 'child_removed' ? undefined : snapshot.val()\n      const resultPath =\n        storeAs || type === 'value' ? path : `${path}/${snapshot.key}`\n\n      // Dispatch standard event if no populates exists\n      if (!populates) {\n        // create an array for preserving order of children under ordered\n        const ordered =\n          type === 'child_added'\n            ? [{ key: snapshot.key, value: snapshot.val() }]\n            : orderedFromSnapshot(snapshot)\n        return dispatch({\n          type: actionTypes.SET,\n          path: storeAs || resultPath,\n          data,\n          ordered\n        })\n      }\n      // populate and dispatch associated actions if populates exist\n      return populateAndDispatch(firebase, dispatch, {\n        path,\n        storeAs,\n        snapshot,\n        data: snapshot.val(),\n        populates\n      })\n    },\n    (err) => {\n      if (logErrors) {\n        // eslint-disable-next-line no-console\n        console.log(\n          `Error retrieving data for path: ${path}, storeAs: ${storeAs}. Firebase:`,\n          err\n        )\n      }\n      dispatch({\n        type: actionTypes.ERROR,\n        storeAs,\n        path,\n        payload: err\n      })\n    }\n  )\n}\n\n/**\n * Remove watcher from an event\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {object} config - Config object\n * @param {string} config.type - Type for which to remove the watcher (\n * value, once, first_child etc.)\n * @param {string} config.path - Path of watcher to remove\n * @param {string} config.storeAs - Path which to store results within in\n * redux store\n * @param {string} config.queryId - Id of the query (used for idendifying)\n * in internal watchers list\n */\nexport function unWatchEvent(\n  firebase,\n  dispatch,\n  { type, path, storeAs, queryId }\n) {\n  const watchPath = !storeAs ? path : `${path}@${storeAs}`\n  unsetWatcher(firebase, dispatch, type, watchPath, queryId)\n}\n\n/**\n * Add watchers to a list of events\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {Array} events - List of events for which to add watchers\n * @returns {Array} ARray of watchEvent results\n */\nexport function watchEvents(firebase, dispatch, events) {\n  if (!Array.isArray(events)) {\n    throw new Error('Events config must be an Array')\n  }\n  return events.map((event) => watchEvent(firebase, dispatch, event))\n}\n\n/**\n * Remove watchers from a list of events\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {Array} events - List of events for which to remove watchers\n */\nexport function unWatchEvents(firebase, dispatch, events) {\n  events?.forEach((event) => unWatchEvent(firebase, dispatch, event))\n}\n\n/**\n * Add watchers to a list of events\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {string} path - Path of ref to be removed\n * @param {object} [options={}] - Configuration for removal\n * @param {boolean} [options.dispatchAction=true] - Whether or not to dispatch\n * REMOVE action\n * @returns {Promise} Resolves with path\n */\nexport function remove(firebase, dispatch, path, options = {}) {\n  const { dispatchAction = true } = options\n  const { dispatchRemoveAction } = firebase._.config\n  return firebase\n    .database()\n    .ref(path)\n    .remove()\n    .then(() => {\n      if (dispatchRemoveAction && dispatchAction) {\n        dispatch({ type: actionTypes.REMOVE, path })\n      }\n      return path\n    })\n    .catch((err) => {\n      dispatch({ type: actionTypes.ERROR, payload: err })\n      return Promise.reject(err)\n    })\n}\n"]},"metadata":{},"sourceType":"script"}