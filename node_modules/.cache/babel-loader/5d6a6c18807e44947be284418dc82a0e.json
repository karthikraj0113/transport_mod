{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.default = firestoreConnect;\nvar _isEqual2 = _interopRequireDefault(require(\"lodash/isEqual\")),\n  _react = _interopRequireWildcard(require(\"react\")),\n  _propTypes = _interopRequireDefault(require(\"prop-types\")),\n  _hoistNonReactStatics = _interopRequireDefault(require(\"hoist-non-react-statics\")),\n  _utils = require(\"./utils\"),\n  _ReduxFirestoreContext = _interopRequireDefault(require(\"./ReduxFirestoreContext\")),\n  _ReactReduxFirebaseContext = _interopRequireDefault(require(\"./ReactReduxFirebaseContext\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (\"function\" != typeof WeakMap) return null;\n  var cacheBabelInterop = new WeakMap(),\n    cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) return obj;\n  if (null === obj || \"object\" !== _typeof(obj) && \"function\" != typeof obj) return {\n    default: obj\n  };\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) return cache.get(obj);\n  var newObj = {},\n    hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) if (\"default\" != key && Object.prototype.hasOwnProperty.call(obj, key)) {\n    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n    desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];\n  }\n  return newObj.default = obj, cache && cache.set(obj, newObj), newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _extends() {\n  return _extends = Object.assign || function (target) {\n    for (var source, i = 1; i < arguments.length; i++) for (var key in source = arguments[i], source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);\n    return target;\n  }, _extends.apply(this, arguments);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(target, props) {\n  for (var descriptor, i = 0; i < props.length; i++) descriptor = props[i], descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;\n}\nfunction _inherits(subClass, superClass) {\n  if (\"function\" != typeof superClass && null !== superClass) throw new TypeError(\"Super expression must either be null or a function\");\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: !0,\n      configurable: !0\n    }\n  }), superClass && _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  return _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    return o.__proto__ = p, o;\n  }, _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function () {\n    var result,\n      Super = _getPrototypeOf(Derived);\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else result = Super.apply(this, arguments);\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (\"object\" === _typeof(call) || \"function\" == typeof call)) return call;\n  if (void 0 !== call) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n  try {\n    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n  } catch (e) {\n    return !1;\n  }\n}\nfunction _getPrototypeOf(o) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, _getPrototypeOf(o);\n}\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\nfunction firestoreConnect() {\n  var queriesConfig = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : [];\n  return function (WrappedComponent) {\n    function FirestoreConnectWithContext(props) {\n      return _react.default.createElement(_ReactReduxFirebaseContext.default.Consumer, null, function (_internalFirebase) {\n        return _react.default.createElement(_ReduxFirestoreContext.default.Consumer, null, function (_internalFirestore) {\n          return _react.default.createElement(FirestoreConnectWrapped, _extends({}, props, {\n            dispatch: _internalFirebase.dispatch,\n            firestore: _internalFirestore,\n            firebase: _internalFirebase\n          }));\n        });\n      });\n    }\n    var FirestoreConnectWrapped = function (_Component) {\n      function FirestoreConnectWrapped() {\n        var _this;\n        _classCallCheck(this, FirestoreConnectWrapped);\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n        return _this = _super.call.apply(_super, [this].concat(args)), _defineProperty(_assertThisInitialized(_this), \"prevData\", null), _this;\n      }\n      _inherits(FirestoreConnectWrapped, _Component);\n      var _super = _createSuper(FirestoreConnectWrapped);\n      return _createClass(FirestoreConnectWrapped, [{\n        key: \"firestoreIsEnabled\",\n        get: function get() {\n          return !!this.props.firestore;\n        }\n      }, {\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          if (this.firestoreIsEnabled) {\n            var inputAsFunc = (0, _utils.createCallable)(queriesConfig);\n            this.prevData = inputAsFunc(this.props, this.props), this.props.firestore.setListeners(this.prevData);\n          }\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.firestoreIsEnabled && this.prevData && this.props.firestore.unsetListeners(this.prevData);\n        }\n      }, {\n        key: \"UNSAFE_componentWillReceiveProps\",\n        value: function UNSAFE_componentWillReceiveProps(np) {\n          var firestore = this.props.firestore,\n            inputAsFunc = (0, _utils.createCallable)(queriesConfig),\n            data = inputAsFunc(np, this.props);\n          if (this.firestoreIsEnabled && !(0, _isEqual2.default)(data, this.prevData)) {\n            var changes = (0, _utils.getChanges)(data, this.prevData);\n            this.prevData = data, firestore.unsetListeners(changes.removed), firestore.setListeners(changes.added);\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          return _react.default.createElement(WrappedComponent, this.props);\n        }\n      }]), FirestoreConnectWrapped;\n    }(_react.Component);\n    return _defineProperty(FirestoreConnectWrapped, \"wrappedComponent\", WrappedComponent), _defineProperty(FirestoreConnectWrapped, \"displayName\", (0, _utils.wrapDisplayName)(WrappedComponent, \"FirestoreConnectWrapped\")), FirestoreConnectWrapped.propTypes = {\n      dispatch: _propTypes.default.func.isRequired,\n      firebase: _propTypes.default.object,\n      firestore: _propTypes.default.object\n    }, FirestoreConnectWithContext.displayName = (0, _utils.wrapDisplayName)(WrappedComponent, \"FirestoreConnect\"), FirestoreConnectWithContext.wrappedComponent = WrappedComponent, (0, _hoistNonReactStatics.default)(FirestoreConnectWithContext, WrappedComponent);\n  };\n}\nmodule.exports = exports.default;","map":{"version":3,"sources":["../src/firestoreConnect.js"],"names":["firestoreConnect","queriesConfig","WrappedComponent","FirestoreConnectWrapped","Component","props","firestore","firestoreIsEnabled","inputAsFunc","prevData","setListeners","unsetListeners","np","data","changes","removed","added","propTypes","dispatch","PropTypes","func","isRequired","firebase","object","FirestoreConnectWithContext","_internalFirebase","_internalFirestore","displayName","wrappedComponent"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { isEqual } from 'lodash'\nimport hoistStatics from 'hoist-non-react-statics'\nimport { createCallable, wrapDisplayName, getChanges } from './utils'\nimport ReduxFirestoreContext from './ReduxFirestoreContext'\nimport ReactReduxFirebaseContext from './ReactReduxFirebaseContext'\n\n/**\n * @augments React.Component\n * @description Higher Order Component that automatically listens/unListens\n * to provided Cloud Firestore paths using React's Lifecycle hooks. Make sure you\n * have required/imported Cloud Firestore, including it's reducer, before\n * attempting to use. **Note** Populate is not yet supported.\n * @param {Array|Function} queriesConfig - Array of objects or strings for paths to sync\n * from Firebase. Can also be a function that returns the array. The function\n * is passed the current props and the firebase object.\n * @returns {Function} - Function which accepts a component to wrap and returns the\n * wrapped component\n * @see https://react-redux-firebase.com/docs/api/firestoreConnect.html\n * @example <caption>Basic</caption>\n * // props.firebase set on App component as firebase object with helpers\n * import { firestoreConnect } from 'react-redux-firebase'\n * export default firestoreConnect()(SomeComponent)\n * @example <caption>Basic</caption>\n * import { connect } from 'react-redux'\n * import { firestoreConnect } from 'react-redux-firebase'\n *\n * // pass todos list from redux as props.todosList\n * export default compose(\n *   firestoreConnect(() => ['todos']), // sync todos collection from Firestore into redux\n *   connect((state) => ({\n *     todosList: state.firestore.data.todos\n *   })\n * )(SomeComponent)\n */\nexport default function firestoreConnect(queriesConfig = []) {\n  return (WrappedComponent) => {\n    class FirestoreConnectWrapped extends Component {\n      static wrappedComponent = WrappedComponent\n      static displayName = wrapDisplayName(\n        WrappedComponent,\n        'FirestoreConnectWrapped'\n      )\n\n      prevData = null\n\n      get firestoreIsEnabled() {\n        return !!this.props.firestore\n      }\n\n      componentDidMount() {\n        if (this.firestoreIsEnabled) {\n          // Listener configs as object (handling function being passed)\n          const inputAsFunc = createCallable(queriesConfig)\n          this.prevData = inputAsFunc(this.props, this.props)\n          // Attach listeners based on listener config\n          this.props.firestore.setListeners(this.prevData)\n        }\n      }\n\n      componentWillUnmount() {\n        if (this.firestoreIsEnabled && this.prevData) {\n          this.props.firestore.unsetListeners(this.prevData)\n        }\n      }\n\n      /* eslint-disable camelcase */\n      UNSAFE_componentWillReceiveProps(np) {\n        /* eslint-enable camelcase */\n        const { firestore } = this.props\n        const inputAsFunc = createCallable(queriesConfig)\n        const data = inputAsFunc(np, this.props)\n\n        // Check for changes in the listener configs\n        if (this.firestoreIsEnabled && !isEqual(data, this.prevData)) {\n          const changes = getChanges(data, this.prevData)\n\n          this.prevData = data\n\n          // Remove listeners for inactive subscriptions\n          firestore.unsetListeners(changes.removed)\n\n          // Add listeners for new subscriptions\n          firestore.setListeners(changes.added)\n        }\n      }\n\n      render() {\n        return <WrappedComponent {...this.props} />\n      }\n    }\n\n    FirestoreConnectWrapped.propTypes = {\n      dispatch: PropTypes.func.isRequired,\n      firebase: PropTypes.object,\n      firestore: PropTypes.object\n    }\n\n    /**\n     * Render component wrapped in context\n     * @param {object} props - Component props\n     * @returns {React.Component} Component wrapped in context\n     */\n    function FirestoreConnectWithContext(props) {\n      return (\n        <ReactReduxFirebaseContext.Consumer>\n          {(_internalFirebase) => (\n            <ReduxFirestoreContext.Consumer>\n              {(_internalFirestore) => (\n                <FirestoreConnectWrapped\n                  {...props}\n                  dispatch={_internalFirebase.dispatch}\n                  firestore={_internalFirestore}\n                  firebase={_internalFirebase}\n                />\n              )}\n            </ReduxFirestoreContext.Consumer>\n          )}\n        </ReactReduxFirebaseContext.Consumer>\n      )\n    }\n\n    FirestoreConnectWithContext.displayName = wrapDisplayName(\n      WrappedComponent,\n      'FirestoreConnect'\n    )\n\n    FirestoreConnectWithContext.wrappedComponent = WrappedComponent\n\n    return hoistStatics(FirestoreConnectWithContext, WrappedComponent)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}