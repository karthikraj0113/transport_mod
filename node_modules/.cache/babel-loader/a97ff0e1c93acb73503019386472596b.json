{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.deleteFile = deleteFile, exports.uploadFileWithProgress = uploadFileWithProgress, exports.writeMetadataToDb = writeMetadataToDb;\nvar _isUndefined2 = _interopRequireDefault(require(\"lodash/isUndefined\")),\n  _omitBy2 = _interopRequireDefault(require(\"lodash/omitBy\")),\n  _constants = require(\"../constants\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar FILE_UPLOAD_ERROR = _constants.actionTypes.FILE_UPLOAD_ERROR,\n  FILE_UPLOAD_PROGRESS = _constants.actionTypes.FILE_UPLOAD_PROGRESS;\nfunction deleteFile(firebase, _ref) {\n  var path = _ref.path,\n    dbPath = _ref.dbPath;\n  return firebase.storage().ref(path).delete().then(function () {\n    if (!dbPath || !firebase.database && !firebase.firestore) return {\n      path: path\n    };\n    return function metaDeletePromise() {\n      return firebase._.config.useFirestoreForStorageMeta ? firebase.firestore().doc(dbPath).delete() : firebase.database().ref(dbPath).remove();\n    }().then(function () {\n      return {\n        path: path,\n        dbPath: dbPath\n      };\n    });\n  });\n}\nfunction createUploadMetaResponseHandler(_ref2) {\n  var fileData = _ref2.fileData,\n    firebase = _ref2.firebase,\n    uploadTaskSnapshot = _ref2.uploadTaskSnapshot,\n    downloadURL = _ref2.downloadURL;\n  return function (metaDataSnapshot) {\n    var useFirestoreForStorageMeta = firebase._.config.useFirestoreForStorageMeta,\n      result = {\n        snapshot: metaDataSnapshot,\n        key: metaDataSnapshot.key || metaDataSnapshot.id,\n        File: fileData,\n        metaDataSnapshot: metaDataSnapshot,\n        uploadTaskSnapshot: uploadTaskSnapshot,\n        uploadTaskSnaphot: uploadTaskSnapshot,\n        createdAt: useFirestoreForStorageMeta ? firebase.firestore.FieldValue.serverTimestamp() : firebase.database.ServerValue.TIMESTAMP\n      };\n    return metaDataSnapshot.id && (result.id = metaDataSnapshot.id), downloadURL && (result.downloadURL = downloadURL), result;\n  };\n}\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  return uploadTaskSnapshot.ref && \"function\" == typeof uploadTaskSnapshot.ref.getDownloadURL ? uploadTaskSnapshot.ref.getDownloadURL() : Promise.resolve(uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]);\n}\nfunction writeMetadataToDb(_ref3) {\n  var firebase = _ref3.firebase,\n    uploadTaskSnapshot = _ref3.uploadTaskSnapshot,\n    dbPath = _ref3.dbPath,\n    options = _ref3.options,\n    _firebase$_$config = firebase._.config,\n    fileMetadataFactory = _firebase$_$config.fileMetadataFactory,\n    useFirestoreForStorageMeta = _firebase$_$config.useFirestoreForStorageMeta,\n    metadataFactory = options.metadataFactory,\n    documentId = options.documentId,\n    useSetForMetadata = options.useSetForMetadata,\n    metaFactoryFunction = metadataFactory || fileMetadataFactory;\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(function (downloadURL) {\n    var fileData = \"function\" == typeof metaFactoryFunction ? metaFactoryFunction(uploadTaskSnapshot, firebase, uploadTaskSnapshot.metadata, downloadURL) : (0, _omitBy2.default)(uploadTaskSnapshot.metadata, _isUndefined2.default),\n      resultFromSnap = createUploadMetaResponseHandler({\n        fileData: fileData,\n        firebase: firebase,\n        uploadTaskSnapshot: uploadTaskSnapshot,\n        downloadURL: downloadURL\n      }),\n      documentIdFromOptions = \"function\" == typeof documentId ? documentId(uploadTaskSnapshot, firebase, uploadTaskSnapshot.metadata, downloadURL) : documentId;\n    return function metaSetPromise(fileData) {\n      if (useFirestoreForStorageMeta) {\n        if (documentIdFromOptions) {\n          var docRef = firebase.firestore().collection(dbPath).doc(documentIdFromOptions);\n          return !1 === useSetForMetadata ? docRef.update(fileData).then(function () {\n            return docRef;\n          }) : docRef.set(fileData, {\n            merge: !0\n          }).then(function () {\n            return docRef;\n          });\n        }\n        return firebase.firestore().collection(dbPath).add(fileData);\n      }\n      var newMetaRef = firebase.database().ref(dbPath).push();\n      return newMetaRef.set(fileData).then(function () {\n        return newMetaRef;\n      });\n    }(fileData).then(resultFromSnap);\n  });\n}\nfunction uploadFileWithProgress(dispatch, firebase, _ref4) {\n  var path = _ref4.path,\n    file = _ref4.file,\n    filename = _ref4.filename,\n    meta = _ref4.meta,\n    fileMetadata = _ref4.fileMetadata,\n    uploadEvent = firebase.storage().ref(\"\".concat(path, \"/\").concat(filename)).put(file, fileMetadata),\n    unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n      next: function next(snapshot) {\n        dispatch({\n          type: FILE_UPLOAD_PROGRESS,\n          meta: meta,\n          payload: {\n            snapshot: snapshot,\n            percent: Math.floor(100 * (snapshot.bytesTransferred / snapshot.totalBytes))\n          }\n        });\n      },\n      error: function error(err) {\n        dispatch({\n          type: FILE_UPLOAD_ERROR,\n          meta: meta,\n          payload: err\n        }), unListen();\n      },\n      complete: function complete() {\n        unListen();\n      }\n    });\n  return uploadEvent;\n}","map":{"version":3,"sources":["../../src/utils/storage.js"],"names":["FILE_UPLOAD_ERROR","FILE_UPLOAD_PROGRESS","actionTypes","deleteFile","firebase","path","dbPath","storage","ref","delete","then","database","firestore","metaDeletePromise","_","config","useFirestoreForStorageMeta","doc","remove","createUploadMetaResponseHandler","fileData","uploadTaskSnapshot","downloadURL","metaDataSnapshot","result","snapshot","key","id","File","uploadTaskSnaphot","createdAt","FieldValue","serverTimestamp","ServerValue","TIMESTAMP","getDownloadURLFromUploadTaskSnapshot","getDownloadURL","Promise","resolve","downloadURLs","writeMetadataToDb","options","fileMetadataFactory","metadataFactory","documentId","useSetForMetadata","metaFactoryFunction","metadata","resultFromSnap","documentIdFromOptions","metaSetPromise","docRef","collection","update","set","merge","add","newMetaRef","push","uploadFileWithProgress","dispatch","file","filename","meta","fileMetadata","uploadEvent","put","unListen","on","TaskEvent","STATE_CHANGED","next","type","payload","percent","Math","floor","bytesTransferred","totalBytes","error","err","complete"],"mappings":"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","sourcesContent":["import { omitBy, isUndefined } from 'lodash'\nimport { actionTypes } from '../constants'\n\nconst { FILE_UPLOAD_ERROR, FILE_UPLOAD_PROGRESS } = actionTypes\n\n/**\n * Delete file from Firebase Storage with support for deleteing meta\n * data from database (either Real Time Database or Firestore depending on\n * config)\n * @param {object} firebase - Internal firebase object\n * @param {object} settings - Settings object\n * @param {string} settings.path - Path to File which should be deleted\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @returns {Promise} Resolves with path and dbPath\n */\nexport function deleteFile(firebase, { path, dbPath }) {\n  return firebase\n    .storage()\n    .ref(path)\n    .delete()\n    .then(() => {\n      // return path if dbPath or a database does not exist\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        return { path }\n      }\n\n      // Choose delete function based on config (Handling Firestore and RTDB)\n      const metaDeletePromise = () =>\n        firebase._.config.useFirestoreForStorageMeta\n          ? firebase.firestore().doc(dbPath).delete() // file meta in Firestore\n          : firebase.database().ref(dbPath).remove() // file meta in RTDB\n\n      return metaDeletePromise().then(() => ({ path, dbPath }))\n    })\n}\n\n/**\n * Create a function to handle response from upload.\n * @param {object} settings - Settings object\n * @param {object} settings.fileData - File data which was uploaded\n * @param {object} settings.uploadTaskSnapshot - Snapshot from storage upload task\n * @param {object} settings.firebase - Firebase instance\n * @param {string} settings.downloadURL - Download url\n * @returns {Function} Function for handling upload result\n */\nfunction createUploadMetaResponseHandler({\n  fileData,\n  firebase,\n  uploadTaskSnapshot,\n  downloadURL\n}) {\n  /**\n   * Converts upload meta data snapshot into an object (handling both\n   * RTDB and Firestore)\n   * @param  {object} metaDataSnapshot - Snapshot from metadata upload (from\n   * RTDB or Firestore)\n   * @returns {object} Upload result including snapshot, key, File\n   */\n  return function uploadResultFromSnap(metaDataSnapshot) {\n    const { useFirestoreForStorageMeta } = firebase._.config\n    const result = {\n      snapshot: metaDataSnapshot,\n      key: metaDataSnapshot.key || metaDataSnapshot.id,\n      File: fileData,\n      metaDataSnapshot,\n      uploadTaskSnapshot,\n      // Support legacy method\n      uploadTaskSnaphot: uploadTaskSnapshot,\n      createdAt: useFirestoreForStorageMeta\n        ? firebase.firestore.FieldValue.serverTimestamp()\n        : firebase.database.ServerValue.TIMESTAMP\n    }\n    // Attach id if it exists (Firestore)\n    if (metaDataSnapshot.id) {\n      result.id = metaDataSnapshot.id\n    }\n    // Attach downloadURL if it exists\n    if (downloadURL) {\n      result.downloadURL = downloadURL\n    }\n    return result\n  }\n}\n\n/**\n * Get download URL from upload task snapshot\n * @param {firebase.storage.UploadTaskSnapshot} uploadTaskSnapshot - Upload task snapshot\n * @returns {Promise} Resolves with download URL\n */\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  // Handle different downloadURL patterns (Firebase JS SDK v5.*.* vs v4.*.*)\n  if (\n    uploadTaskSnapshot.ref &&\n    typeof uploadTaskSnapshot.ref.getDownloadURL === 'function'\n  ) {\n    // Get downloadURL and attach to response\n    return uploadTaskSnapshot.ref.getDownloadURL()\n  }\n  // Only attach downloadURL if downloadURLs is defined (not defined in v5.*.*)\n  return Promise.resolve(\n    uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]\n  )\n}\n\n/**\n * Write file metadata to Database (either Real Time Datbase or Firestore\n * depending on config).\n * @param {object} settings - Settings object\n * @param {object} settings.firebase - Internal firebase object\n * @param {object} settings.uploadTaskSnapshot - Snapshot from upload task\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @param {object} settings.options - Options object\n * @returns {Promise} Resolves with payload (includes snapshot, File, and\n * metaDataSnapshot)\n */\nexport function writeMetadataToDb({\n  firebase,\n  uploadTaskSnapshot,\n  dbPath,\n  options\n}) {\n  // Support metadata factories from both global config and options\n  const { fileMetadataFactory, useFirestoreForStorageMeta } = firebase._.config\n  const { metadataFactory, documentId, useSetForMetadata } = options\n  const metaFactoryFunction = metadataFactory || fileMetadataFactory\n  // Get download URL for use in metadata write\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(\n    (downloadURL) => {\n      // Apply fileMetadataFactory if it exists in config\n      const fileData =\n        typeof metaFactoryFunction === 'function'\n          ? metaFactoryFunction(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : omitBy(uploadTaskSnapshot.metadata, isUndefined)\n\n      // Create the snapshot handler function\n      const resultFromSnap = createUploadMetaResponseHandler({\n        fileData,\n        firebase,\n        uploadTaskSnapshot,\n        downloadURL\n      })\n\n      // Function for creating promise for writing file metadata (handles writing to RTDB or Firestore)\n      const documentIdFromOptions =\n        typeof documentId === 'function'\n          ? documentId(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : documentId\n      const metaSetPromise = (fileData) => {\n        if (useFirestoreForStorageMeta) {\n          if (documentIdFromOptions) {\n            const docRef = firebase // Write metadata to Firestore\n              .firestore()\n              .collection(dbPath)\n              .doc(documentIdFromOptions)\n            return useSetForMetadata === false\n              ? docRef.update(fileData).then(() => docRef)\n              : docRef.set(fileData, { merge: true }).then(() => docRef)\n          }\n          return firebase.firestore().collection(dbPath).add(fileData)\n        }\n        // Create new reference for metadata\n        const newMetaRef = firebase.database().ref(dbPath).push()\n        // Write metadata to Real Time Database and return new meta ref\n        return newMetaRef.set(fileData).then((res) => newMetaRef)\n      }\n\n      return metaSetPromise(fileData).then(resultFromSnap)\n    }\n  )\n}\n\n/**\n * Upload a file with actions fired for progress, success, and errors\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - File data object\n * @param {object} opts.path - Location within Firebase Stroage at which to upload file.\n * @param {Blob} opts.file - File to upload\n * @param {object} opts.fileMetadata - Metadata to pass along to storageRef.put call\n * @param {object} opts.meta - Meta object\n * @returns {Promise} Promise which resolves after file upload\n * @private\n */\nexport function uploadFileWithProgress(\n  dispatch,\n  firebase,\n  { path, file, filename, meta, fileMetadata }\n) {\n  const uploadEvent = firebase\n    .storage()\n    .ref(`${path}/${filename}`)\n    .put(file, fileMetadata)\n\n  const unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n    next: (snapshot) => {\n      dispatch({\n        type: FILE_UPLOAD_PROGRESS,\n        meta,\n        payload: {\n          snapshot,\n          percent: Math.floor(\n            (snapshot.bytesTransferred / snapshot.totalBytes) * 100\n          )\n        }\n      })\n    },\n    error: (err) => {\n      dispatch({ type: FILE_UPLOAD_ERROR, meta, payload: err })\n      unListen()\n    },\n    complete: () => {\n      unListen()\n    }\n  })\n  return uploadEvent\n}\n"]},"metadata":{},"sourceType":"script"}