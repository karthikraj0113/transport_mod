{"ast":null,"code":"var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : (obj = {}, obj[\"immer-nothing\"] = true, obj);\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value) {\n    return false;\n  }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n} // We use Maps as `drafts` for Sets, not Objects\n// See proxy.js\n\nfunction assignSet(target, override) {\n  override.forEach(function (value) {\n    // When we add new drafts we have to remove their originals if present\n    var prev = original(value);\n    if (prev) {\n      target.delete(prev);\n    }\n    target.add(value);\n  });\n  return target;\n} // We use Maps as `drafts` for Maps, not Objects\n// See proxy.js\n\nfunction assignMap(target, override) {\n  override.forEach(function (value, key) {\n    return target.set(key, value);\n  });\n  return target;\n}\nvar assign = Object.assign || function (target) {\n  var overrides = [],\n    len = arguments.length - 1;\n  while (len-- > 0) overrides[len] = arguments[len + 1];\n  overrides.forEach(function (override) {\n    return Object.keys(override).forEach(function (key) {\n      return target[key] = override[key];\n    });\n  });\n  return target;\n};\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) invokeGetters = false;\n  if (Array.isArray(base)) {\n    return base.slice();\n  }\n  if (isMap(base)) {\n    return new Map(base);\n  }\n  if (isSet(base)) {\n    return new Set(base);\n  }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n      value = desc.get.call(base);\n    }\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(obj, iter) {\n  if (Array.isArray(obj) || isMap(obj) || isSet(obj)) {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  } else {\n    ownKeys(obj).forEach(function (key) {\n      return iter(key, obj[key], obj);\n    });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return isMap(thing) ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return isMap(thing) ? thing.get(prop) : thing[prop];\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\nvar hasSet = typeof Set !== \"undefined\";\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\nfunction makeIterable(next) {\n  var obj;\n  var self;\n  return self = (obj = {}, obj[Symbol.iterator] = function () {\n    return self;\n  }, obj.next = next, obj);\n}\n/** Map.prototype.values _-or-_ Map.prototype.entries */\n\nfunction iterateMapValues(state, prop, receiver) {\n  var isEntries = prop !== \"values\";\n  return function () {\n    var iterator = latest(state)[Symbol.iterator]();\n    return makeIterable(function () {\n      var result = iterator.next();\n      if (!result.done) {\n        var ref = result.value;\n        var key = ref[0];\n        var value = receiver.get(key);\n        result.value = isEntries ? [key, value] : value;\n      }\n      return result;\n    });\n  };\n}\nfunction makeIterateSetValues(createProxy) {\n  function iterateSetValues(state, prop) {\n    var isEntries = prop === \"entries\";\n    return function () {\n      var iterator = latest(state)[Symbol.iterator]();\n      return makeIterable(function () {\n        var result = iterator.next();\n        if (!result.done) {\n          var value = wrapSetValue(state, result.value);\n          result.value = isEntries ? [value, value] : value;\n        }\n        return result;\n      });\n    };\n  }\n  function wrapSetValue(state, value) {\n    var key = original(value) || value;\n    var draft = state.drafts.get(key);\n    if (!draft) {\n      if (state.finalized || !isDraftable(value) || state.finalizing) {\n        return value;\n      }\n      draft = createProxy(value, state);\n      state.drafts.set(key, draft);\n      if (state.modified) {\n        state.copy.add(draft);\n      }\n    }\n    return draft;\n  }\n  return iterateSetValues;\n}\nfunction latest(state) {\n  return state.copy || state.base;\n}\nfunction clone(obj) {\n  if (!isDraftable(obj)) {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n  if (isMap(obj)) {\n    return new Map(obj);\n  }\n  if (isSet(obj)) {\n    return new Set(obj);\n  }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n  for (var key in obj) {\n    cloned[key] = clone(obj[key]);\n  }\n  return cloned;\n}\nfunction freeze(obj, deep) {\n  if (deep === void 0) deep = false;\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) {\n    return;\n  }\n  if (isSet(obj)) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (isMap(obj)) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n  Object.freeze(obj);\n  if (deep) {\n    each(obj, function (_, value) {\n      return freeze(value, true);\n    });\n  }\n}\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\nImmerScope.prototype.usePatches = function usePatches(patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\nImmerScope.prototype.revoke = function revoke$1() {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave() {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n    markChangesSweep(scope.drafts);\n  }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  if (isMap(base)) {\n    proxyMap(draft);\n  } else if (isSet(base)) {\n    proxySet(draft);\n  } else {\n    each(draft, function (prop) {\n      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n    });\n  } // See \"proxy.js\" for property documentation.\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: isMap(base) ? new Map() : {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    drafts: isSet(base) ? new Map() : null,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n  };\n\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\nfunction revoke$1() {\n  this.revoked = true;\n}\nfunction latest$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n  return draft[prop];\n}\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(latest$1(state), prop);\n  if (state.finalizing) {\n    return value;\n  } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n  return value;\n}\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n  if (!state.modified) {\n    if (is(value, peek(latest$1(state), prop))) {\n      return;\n    }\n    markChanged(state);\n    prepareCopy(state);\n  }\n  state.copy[prop] = value;\n}\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) {\n      markChanged(state.parent);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy) {\n    state.copy = clonePotentialDraft(state.base);\n  }\n}\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\nvar descriptors = {};\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function get$1$1() {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n  Object.defineProperty(draft, prop, desc);\n}\nfunction proxyMap(target) {\n  Object.defineProperties(target, mapTraps);\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateMapValues));\n  }\n}\nvar mapTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  has: function (state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  set: function (state) {\n    return function (key, value) {\n      if (latest$1(state).get(key) !== value) {\n        prepareCopy(state);\n        markChanged(state);\n        state.assigned.set(key, true);\n        state.copy.set(key, value);\n      }\n      return state.draft;\n    };\n  },\n  delete: function (state) {\n    return function (key) {\n      prepareCopy(state);\n      markChanged(state);\n      state.assigned.set(key, false);\n      state.copy.delete(key);\n      return false;\n    };\n  },\n  clear: function (state) {\n    return function () {\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n      markChanged(state);\n      state.assigned = new Map();\n      for (var i = 0, list = latest$1(state).keys(); i < list.length; i += 1) {\n        var key = list[i];\n        state.assigned.set(key, false);\n      }\n      return state.copy.clear();\n    };\n  },\n  forEach: function (state, key, reciever) {\n    return function (cb) {\n      latest$1(state).forEach(function (value, key, map) {\n        cb(reciever.get(key), key, map);\n      });\n    };\n  },\n  get: function (state) {\n    return function (key) {\n      var value = latest$1(state).get(key);\n      if (state.finalizing || state.finalized || !isDraftable(value)) {\n        return value;\n      }\n      if (value !== state.base.get(key)) {\n        return value;\n      }\n      var draft = createProxy(value, state);\n      prepareCopy(state);\n      state.copy.set(key, draft);\n      return draft;\n    };\n  },\n  keys: function (state) {\n    return function () {\n      return latest$1(state).keys();\n    };\n  },\n  values: iterateMapValues,\n  entries: iterateMapValues\n});\nfunction proxySet(target) {\n  Object.defineProperties(target, setTraps);\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateSetValues));\n  }\n}\nvar iterateSetValues = makeIterateSetValues(createProxy);\nvar setTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  add: function (state) {\n    return function (value) {\n      if (!latest$1(state).has(value)) {\n        markChanged(state);\n        if (!state.copy) {\n          prepareCopy(state);\n        }\n        state.copy.add(value);\n      }\n      return state.draft;\n    };\n  },\n  delete: function (state) {\n    return function (value) {\n      markChanged(state);\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n      return state.copy.delete(value);\n    };\n  },\n  has: function (state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  clear: function (state) {\n    return function () {\n      markChanged(state);\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n      return state.copy.clear();\n    };\n  },\n  keys: iterateSetValues,\n  entries: iterateSetValues,\n  values: iterateSetValues,\n  forEach: function (state) {\n    return function (cb, thisArg) {\n      var iterator = iterateSetValues(state)();\n      var result = iterator.next();\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, state.draft);\n        result = iterator.next();\n      }\n    };\n  }\n});\nfunction finalizeTraps(traps) {\n  return Object.keys(traps).reduce(function (acc, key) {\n    var builder = key === \"size\" ? proxyAttr : proxyMethod;\n    acc[key] = builder(traps[key], key);\n    return acc;\n  }, {});\n}\nfunction proxyAttr(fn) {\n  return {\n    get: function get() {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      return fn(state);\n    }\n  };\n}\nfunction proxyMethod(trap, key) {\n  return {\n    get: function get() {\n      return function () {\n        var args = [],\n          len = arguments.length;\n        while (len--) args[len] = arguments[len];\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        return trap(state, key, state.draft).apply(void 0, args);\n      };\n    }\n  };\n}\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) {\n    throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest$1(state)));\n  }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) {\n          markChanged(state);\n        }\n      } else if (isMap(state.base)) {\n        if (hasMapChanges(state)) {\n          markChanged(state);\n        }\n      } else if (isSet(state.base)) {\n        if (hasSetChanges(state)) {\n          markChanged(state);\n        }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") {\n    return;\n  }\n  var state = object[DRAFT_STATE];\n  if (!state) {\n    return;\n  }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) {\n        assigned[i$1] = true;\n      }\n    }\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) {\n        markChangesRecursively(draft[i$2]);\n      }\n    }\n  }\n}\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n      var value = draft[key];\n      var state$1 = value && value[DRAFT_STATE];\n      if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n        return true;\n      }\n    }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n  return keys.length !== Object.keys(base).length;\n}\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) {\n    return true;\n  } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) {\n    return true;\n  } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\nfunction hasMapChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n  if (base.size !== draft.size) {\n    return true;\n  } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : value !== base.get(key);\n    }\n  });\n  return hasChanges;\n}\nfunction hasSetChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n  if (base.size !== draft.size) {\n    return true;\n  } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : !base.has(key);\n    }\n  });\n  return hasChanges;\n}\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n  willFinalize: willFinalize,\n  createProxy: createProxy\n});\nvar obj$1, obj$1$1;\nfunction willFinalize$1() {}\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var target = state;\n  var traps = objectTraps;\n  if (Array.isArray(base)) {\n    target = [state];\n    traps = arrayTraps;\n  } // Map drafts must support object keys, so we use Map objects to track changes.\n  else if (isMap(base)) {\n    traps = mapTraps$1;\n    state.drafts = new Map();\n    state.assigned = new Map();\n  } // Set drafts use a Map object to track which of its values are drafted.\n  // And we don't need the \"assigned\" property, because Set objects have no keys.\n  else if (isSet(base)) {\n    traps = setTraps$1;\n    state.drafts = new Map();\n  }\n  var ref = Proxy.revocable(target, traps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n/**\n * Object drafts\n */\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) {\n      return state;\n    }\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n    var value = latest$2(state)[prop];\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek$1(state.base, prop)) {\n        return value;\n      } // Store drafts on the copy (when one exists).\n\n      drafts = state.copy;\n    }\n    return drafts[prop] = createProxy$1(value, state);\n  },\n  has: function has(state, prop) {\n    return prop in latest$2(state);\n  },\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest$2(state));\n  },\n  set: function set(state, prop, value) {\n    if (!state.modified) {\n      var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n      if (isUnchanged) {\n        return true;\n      }\n      markChanged$1(state);\n    }\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n  },\n  deleteProperty: function deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      markChanged$1(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    }\n    if (state.copy) {\n      delete state.copy[prop];\n    }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest$2(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n    }\n    return desc;\n  },\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n\n  getPrototypeOf: function getPrototypeOf(state) {\n    return Object.getPrototypeOf(state.base);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\n/**\n * Array drafts\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // Used by Map and Set drafts\n\nvar reflectTraps = makeReflectTraps([\"ownKeys\", \"has\", \"set\", \"deleteProperty\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"preventExtensions\", \"isExtensible\", \"getPrototypeOf\"]);\n/**\n * Map drafts\n */\n\nvar mapTraps$1 = makeTrapsForGetters((obj$1 = {}, obj$1[DRAFT_STATE] = function (state) {\n  return state;\n}, obj$1.size = function (state) {\n  return latest$2(state).size;\n}, obj$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, obj$1.set = function (state) {\n  return function (key, value) {\n    var values = latest$2(state);\n    if (!values.has(key) || values.get(key) !== value) {\n      markChanged$1(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n    return state.draft;\n  };\n}, obj$1.delete = function (state) {\n  return function (key) {\n    if (latest$2(state).has(key)) {\n      markChanged$1(state);\n      state.assigned.set(key, false);\n      return state.copy.delete(key);\n    }\n    return false;\n  };\n}, obj$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    state.assigned = new Map();\n    for (var i = 0, list = latest$2(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n      state.assigned.set(key, false);\n    }\n    return state.copy.clear();\n  };\n}, obj$1.forEach = function (state, _, receiver) {\n  return function (cb, thisArg) {\n    return latest$2(state).forEach(function (_, key, map) {\n      var value = receiver.get(key);\n      cb.call(thisArg, value, key, map);\n    });\n  };\n}, obj$1.get = function (state) {\n  return function (key) {\n    var drafts = state[state.modified ? \"copy\" : \"drafts\"];\n    if (drafts.has(key)) {\n      return drafts.get(key);\n    }\n    var value = latest$2(state).get(key);\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n    var draft = createProxy$1(value, state);\n    drafts.set(key, draft);\n    return draft;\n  };\n}, obj$1.keys = function (state) {\n  return function () {\n    return latest$2(state).keys();\n  };\n}, obj$1.values = iterateMapValues, obj$1.entries = iterateMapValues, obj$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateMapValues, obj$1));\nvar iterateSetValues$1 = makeIterateSetValues(createProxy$1);\n/**\n * Set drafts\n */\n\nvar setTraps$1 = makeTrapsForGetters((obj$1$1 = {}, obj$1$1[DRAFT_STATE] = function (state) {\n  return state;\n}, obj$1$1.size = function (state) {\n  return latest$2(state).size;\n}, obj$1$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, obj$1$1.add = function (state) {\n  return function (value) {\n    if (!latest$2(state).has(value)) {\n      markChanged$1(state);\n      state.copy.add(value);\n    }\n    return state.draft;\n  };\n}, obj$1$1.delete = function (state) {\n  return function (value) {\n    markChanged$1(state);\n    return state.copy.delete(value);\n  };\n}, obj$1$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    return state.copy.clear();\n  };\n}, obj$1$1.forEach = function (state) {\n  return function (cb, thisArg) {\n    var iterator = iterateSetValues$1(state)();\n    var result = iterator.next();\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  };\n}, obj$1$1.keys = iterateSetValues$1, obj$1$1.values = iterateSetValues$1, obj$1$1.entries = iterateSetValues$1, obj$1$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateSetValues$1, obj$1$1));\n/**\n * Helpers\n */\n// Retrieve the latest values of the draft.\n\nfunction latest$2(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest$2(state) : draft, prop);\n  return desc && desc.value;\n}\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    var base = state.base;\n    var drafts = state.drafts;\n    var parent = state.parent;\n    var copy = shallowCopy(base);\n    if (isSet(base)) {\n      // Note: The `drafts` property is preserved for Set objects, since\n      // we need to keep track of which values are drafted.\n      assignSet(copy, drafts);\n    } else {\n      // Merge nested drafts into the copy.\n      if (isMap(base)) {\n        assignMap(copy, drafts);\n      } else {\n        assign(copy, drafts);\n      }\n      state.drafts = null;\n    }\n    state.copy = copy;\n    if (parent) {\n      markChanged$1(parent);\n    }\n  }\n}\n/** Create traps that all use the `Reflect` API on the `latest(state)` */\n\nfunction makeReflectTraps(names) {\n  return names.reduce(function (traps, name) {\n    traps[name] = function (state) {\n      var args = [],\n        len = arguments.length - 1;\n      while (len-- > 0) args[len] = arguments[len + 1];\n      return Reflect[name].apply(Reflect, [latest$2(state)].concat(args));\n    };\n    return traps;\n  }, {});\n}\nfunction makeTrapsForGetters(getters) {\n  return Object.assign({}, reflectTraps, {\n    get: function get(state, prop, receiver) {\n      return getters.hasOwnProperty(prop) ? getters[prop](state, prop, receiver) : Reflect.get(state, prop, receiver);\n    },\n    setPrototypeOf: function setPrototypeOf(state) {\n      throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n    }\n  });\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n  willFinalize: willFinalize$1,\n  createProxy: createProxy$1\n});\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  var generatePatchesFn = Array.isArray(state.base) ? generateArrayPatches : isSet(state.base) ? generateSetPatches : generatePatchesFromAssigned;\n  generatePatchesFn(state, basePath, patches, inversePatches);\n}\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    assign = [copy, base], base = assign[0], copy = assign[1];\n    assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1];\n  }\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n  var end = base.length;\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") {\n      return;\n    }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  var i = 0;\n  for (var i$1 = 0, list = base; i$1 < list.length; i$1 += 1) {\n    var value = list[i$1];\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n    i++;\n  }\n  i = 0;\n  for (var i$2 = 0, list$1 = copy; i$2 < list$1.length; i$2 += 1) {\n    var value$1 = list$1[i$2];\n    if (!base.has(value$1)) {\n      var path$1 = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path$1,\n        value: value$1\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path$1,\n        value: value$1\n      });\n    }\n    i++;\n  }\n}\nvar applyPatches = function (draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n    var path = patch.path;\n    var op = patch.op;\n    if (!path.length) {\n      throw new Error(\"Illegal state\");\n    }\n    var base = draft;\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n      if (!base || typeof base !== \"object\") {\n        throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\"));\n      } // prettier-ignore\n    }\n\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n    switch (op) {\n      case \"replace\":\n        if (isMap(base)) {\n          base.set(key, value);\n        } else if (isSet(base)) {\n          throw new Error('Sets cannot have \"replace\" patches.');\n        } else {\n          // if value is an object, then it's assigned by reference\n          // in the following add or remove ops, the value field inside the patch will also be modifyed\n          // so we use value from the cloned patch\n          base[key] = value;\n        }\n        break;\n      case \"add\":\n        if (isSet(base)) {\n          base.delete(patch.value);\n        }\n        Array.isArray(base) ? base.splice(key, 0, value) : isMap(base) ? base.set(key, value) : isSet(base) ? base.add(value) : base[key] = value;\n        break;\n      case \"remove\":\n        Array.isArray(base) ? base.splice(key, 1) : isMap(base) ? base.delete(key) : isSet(base) ? base.delete(patch.value) : delete base[key];\n        break;\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n  return draft;\n};\nfunction verifyMinified() {}\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n  this.produceWithPatches = this.produceWithPatches.bind(this);\n};\nImmer.prototype.produce = function produce(base, recipe, patchListener) {\n  var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n      var this$1 = this;\n      if (base === void 0) base = defaultBase;\n      var args = [],\n        len = arguments.length - 1;\n      while (len-- > 0) args[len] = arguments[len + 1];\n      return self.produce(base, function (draft) {\n        return recipe.call.apply(recipe, [this$1, draft].concat(args));\n      }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) {\n        scope.revoke();\n      } else {\n        scope.leave();\n      }\n    }\n    if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === NOTHING) {\n      return undefined;\n    }\n    if (result === undefined) {\n      result = base;\n    }\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\nImmer.prototype.produceWithPatches = function produceWithPatches(arg1, arg2, arg3) {\n  var this$1 = this;\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n      var args = [],\n        len = arguments.length - 1;\n      while (len-- > 0) args[len] = arguments[len + 1];\n      return this$1.produceWithPatches(state, function (draft) {\n        return arg1.apply(void 0, [draft].concat(args));\n      });\n    };\n  } // non-curried form\n\n  if (arg3) {\n    throw new Error(\"A patch listener cannot be passed to produceWithPatches\");\n  }\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\nImmer.prototype.createDraft = function createDraft(base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\nImmer.prototype.finishDraft = function finishDraft(draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\nImmer.prototype.setAutoFreeze = function setAutoFreeze(value) {\n  this.autoFreeze = value;\n};\nImmer.prototype.setUseProxies = function setUseProxies(value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\nImmer.prototype.applyPatches = function applyPatches$1(base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n  return this.produce(base, function (draft) {\n    return applyPatches(draft, patches.slice(i + 1));\n  });\n};\n/** @internal */\n\nImmer.prototype.processResult = function processResult(result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n  scope.revoke();\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\nImmer.prototype.finalize = function finalize(draft, path, scope) {\n  var this$1 = this;\n  var state = draft[DRAFT_STATE];\n  if (!state) {\n    if (Object.isFrozen(draft)) {\n      return draft;\n    }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (this.onDelete && !isSet(state.base)) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      } else {\n        // TODO: Figure it out for Maps and Sets if we need to support ES5\n        var base = state.base;\n        var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      }\n    }\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\nImmer.prototype.finalizeTree = function finalizeTree(root, rootPath, scope) {\n  var this$1 = this;\n  var state = root[DRAFT_STATE];\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n    root = state.copy;\n  }\n  var needPatches = !!rootPath && !!scope.patches;\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n    var isDraftProp = !!state && parent === root;\n    var isSetMember = isSet(parent);\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !isSetMember &&\n      // Set objects are atomic since they have no keys.\n      !has(state.assigned, prop) // Skip deep patches for assigned keys.\n      ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope);\n      replace(parent, prop, value); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n      if (isDraftProp && value === get(state.base, prop)) {\n        return;\n      }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, get(state.base, prop))) {\n      return;\n    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n    else if (isDraftable(value) && !Object.isFrozen(value)) {\n      each(value, finalizeProperty);\n      this$1.maybeFreeze(value);\n    }\n    if (isDraftProp && this$1.onAssign && !isSetMember) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n  each(root, finalizeProperty);\n  return root;\n};\nImmer.prototype.maybeFreeze = function maybeFreeze(value, deep) {\n  if (deep === void 0) deep = false;\n  if (this.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n};\nfunction replace(parent, prop, value) {\n  if (isMap(parent)) {\n    parent.set(prop, value);\n  } else if (isSet(parent)) {\n    // In this case, the `prop` is actually a draft.\n    parent.delete(prop);\n    parent.add(value);\n  } else if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n    // Preserve non-enumerable properties.\n    parent[prop] = value;\n  } else {\n    Object.defineProperty(parent, prop, {\n      value: value,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };","map":{"version":3,"sources":["../src/common.js","../src/scope.js","../src/es5.js","../src/proxy.js","../src/patches.js","../src/immer.js","../src/index.js"],"names":["NOTHING","Symbol","DRAFTABLE","for","const","DRAFT_STATE","isDraft","value","isDraftable","isPlainObject","constructor","isMap","isSet","Array","isArray","proto","Object","getPrototypeOf","prototype","original","base","assignSet","target","override","forEach","prev","delete","add","assignMap","key","set","assign","overrides","keys","ownKeys","Reflect","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","shallowCopy","invokeGetters","slice","Map","Set","clone","create","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","writable","configurable","each","iter","entry","index","isEnumerable","prop","has","thing","hasOwnProperty","is","x","y","hasSymbol","hasMap","hasSet","makeIterable","next","self","iterator","iterateMapValues","state","receiver","isEntries","latest","result","done","makeIterateSetValues","createProxy","iterateSetValues","wrapSetValue","draft","drafts","finalized","finalizing","modified","copy","map","cloned","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","_","ImmerScope","parent","canAutoFreeze","patches","usePatches","patchListener","inversePatches","revoke","leave","current","enter","willFinalize","scope","isReplaced","markChangesRecursively","markChangesSweep","clonePotentialDraft","proxyMap","proxySet","proxyProperty","assigned","revoked","createHiddenProperty","push","peek","assertUnrevoked","prepareCopy","markChanged","descriptors","defineProperties","mapTraps","proxyMethod","finalizeTraps","size","reciever","cb","values","entries","setTraps","thisArg","traps","reduce","acc","builder","proxyAttr","fn","trap","args","JSON","stringify","let","i","length","hasArrayChanges","hasMapChanges","hasSetChanges","hasObjectChanges","object","undefined","baseValue","descriptor","hasChanges","objectTraps","arrayTraps","proxy","Proxy","revocable","isUnchanged","deleteProperty","owner","setPrototypeOf","arguments","apply","isNaN","parseInt","reflectTraps","makeReflectTraps","makeTrapsForGetters","names","name","getters","generatePatches","basePath","generatePatchesFn","generateArrayPatches","generateSetPatches","generatePatchesFromAssigned","delta","start","end","path","op","replaceCount","assignedValue","origValue","unshift","applyPatches","patch","join","splice","verifyMinified","configDefaults","useProxies","autoFreeze","process","env","NODE_ENV","onAssign","onDelete","onCopy","Immer","config","setUseProxies","produce","bind","produceWithPatches","recipe","defaultBase","curriedProduce","this","hasError","Promise","then","processResult","error","maybeFreeze","arg1","arg2","arg3","nextState","p","ip","createDraft","isManual","finishDraft","setAutoFreeze","modernProxy","legacyProxy","baseDraft","finalize","finalizeTree","exists","root","rootPath","needPatches","finalizeProperty","isDraftProp","isSetMember","replace","immer"],"mappings":"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","sourcesContent":["var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : ( obj = {}, obj[\"immer-nothing\"] = true, obj );\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value) { return false; }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n} // We use Maps as `drafts` for Sets, not Objects\n// See proxy.js\n\nfunction assignSet(target, override) {\n  override.forEach(function (value) {\n    // When we add new drafts we have to remove their originals if present\n    var prev = original(value);\n    if (prev) { target.delete(prev); }\n    target.add(value);\n  });\n  return target;\n} // We use Maps as `drafts` for Maps, not Objects\n// See proxy.js\n\nfunction assignMap(target, override) {\n  override.forEach(function (value, key) { return target.set(key, value); });\n  return target;\n}\nvar assign = Object.assign || (function (target) {\n  var overrides = [], len = arguments.length - 1;\n  while ( len-- > 0 ) overrides[ len ] = arguments[ len + 1 ];\n\n  overrides.forEach(function (override) { return Object.keys(override).forEach(function (key) { return target[key] = override[key]; }); });\n  return target;\n});\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) { return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)); } : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if ( invokeGetters === void 0 ) invokeGetters = false;\n\n  if (Array.isArray(base)) { return base.slice(); }\n  if (isMap(base)) { return new Map(base); }\n  if (isSet(base)) { return new Set(base); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(obj, iter) {\n  if (Array.isArray(obj) || isMap(obj) || isSet(obj)) {\n    obj.forEach(function (entry, index) { return iter(index, entry, obj); });\n  } else {\n    ownKeys(obj).forEach(function (key) { return iter(key, obj[key], obj); });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return isMap(thing) ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return isMap(thing) ? thing.get(prop) : thing[prop];\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\nvar hasSet = typeof Set !== \"undefined\";\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\nfunction makeIterable(next) {\n  var obj;\n\n  var self;\n  return self = ( obj = {}, obj[Symbol.iterator] = function () { return self; }, obj.next = next, obj );\n}\n/** Map.prototype.values _-or-_ Map.prototype.entries */\n\nfunction iterateMapValues(state, prop, receiver) {\n  var isEntries = prop !== \"values\";\n  return function () {\n    var iterator = latest(state)[Symbol.iterator]();\n    return makeIterable(function () {\n      var result = iterator.next();\n\n      if (!result.done) {\n        var ref = result.value;\n        var key = ref[0];\n        var value = receiver.get(key);\n        result.value = isEntries ? [key, value] : value;\n      }\n\n      return result;\n    });\n  };\n}\nfunction makeIterateSetValues(createProxy) {\n  function iterateSetValues(state, prop) {\n    var isEntries = prop === \"entries\";\n    return function () {\n      var iterator = latest(state)[Symbol.iterator]();\n      return makeIterable(function () {\n        var result = iterator.next();\n\n        if (!result.done) {\n          var value = wrapSetValue(state, result.value);\n          result.value = isEntries ? [value, value] : value;\n        }\n\n        return result;\n      });\n    };\n  }\n\n  function wrapSetValue(state, value) {\n    var key = original(value) || value;\n    var draft = state.drafts.get(key);\n\n    if (!draft) {\n      if (state.finalized || !isDraftable(value) || state.finalizing) {\n        return value;\n      }\n\n      draft = createProxy(value, state);\n      state.drafts.set(key, draft);\n\n      if (state.modified) {\n        state.copy.add(draft);\n      }\n    }\n\n    return draft;\n  }\n\n  return iterateSetValues;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction clone(obj) {\n  if (!isDraftable(obj)) { return obj; }\n  if (Array.isArray(obj)) { return obj.map(clone); }\n  if (isMap(obj)) { return new Map(obj); }\n  if (isSet(obj)) { return new Set(obj); }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) { cloned[key] = clone(obj[key]); }\n\n  return cloned;\n}\nfunction freeze(obj, deep) {\n  if ( deep === void 0 ) deep = false;\n\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }\n\n  if (isSet(obj)) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (isMap(obj)) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n  if (deep) { each(obj, function (_, value) { return freeze(value, true); }); }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches (patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1 () {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave () {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n\n  if (isMap(base)) {\n    proxyMap(draft);\n  } else if (isSet(base)) {\n    proxySet(draft);\n  } else {\n    each(draft, function (prop) {\n      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n    });\n  } // See \"proxy.js\" for property documentation.\n\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: isMap(base) ? new Map() : {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    drafts: isSet(base) ? new Map() : null,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction latest$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(latest$1(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(latest$1(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n\n      get: function get$1$1() {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction proxyMap(target) {\n  Object.defineProperties(target, mapTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateMapValues));\n  }\n}\n\nvar mapTraps = finalizeTraps({\n  size: function (state) { return latest$1(state).size; },\n  has: function (state) { return function (key) { return latest$1(state).has(key); }; },\n  set: function (state) { return function (key, value) {\n    if (latest$1(state).get(key) !== value) {\n      prepareCopy(state);\n      markChanged(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  }; },\n  delete: function (state) { return function (key) {\n    prepareCopy(state);\n    markChanged(state);\n    state.assigned.set(key, false);\n    state.copy.delete(key);\n    return false;\n  }; },\n  clear: function (state) { return function () {\n    if (!state.copy) {\n      prepareCopy(state);\n    }\n\n    markChanged(state);\n    state.assigned = new Map();\n\n    for (var i = 0, list = latest$1(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  }; },\n  forEach: function (state, key, reciever) { return function (cb) {\n    latest$1(state).forEach(function (value, key, map) {\n      cb(reciever.get(key), key, map);\n    });\n  }; },\n  get: function (state) { return function (key) {\n    var value = latest$1(state).get(key);\n\n    if (state.finalizing || state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    if (value !== state.base.get(key)) {\n      return value;\n    }\n\n    var draft = createProxy(value, state);\n    prepareCopy(state);\n    state.copy.set(key, draft);\n    return draft;\n  }; },\n  keys: function (state) { return function () { return latest$1(state).keys(); }; },\n  values: iterateMapValues,\n  entries: iterateMapValues\n});\n\nfunction proxySet(target) {\n  Object.defineProperties(target, setTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateSetValues));\n  }\n}\n\nvar iterateSetValues = makeIterateSetValues(createProxy);\nvar setTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  add: function (state) { return function (value) {\n    if (!latest$1(state).has(value)) {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  }; },\n  delete: function (state) { return function (value) {\n    markChanged(state);\n\n    if (!state.copy) {\n      prepareCopy(state);\n    }\n\n    return state.copy.delete(value);\n  }; },\n  has: function (state) { return function (key) {\n    return latest$1(state).has(key);\n  }; },\n  clear: function (state) { return function () {\n    markChanged(state);\n\n    if (!state.copy) {\n      prepareCopy(state);\n    }\n\n    return state.copy.clear();\n  }; },\n  keys: iterateSetValues,\n  entries: iterateSetValues,\n  values: iterateSetValues,\n  forEach: function (state) { return function (cb, thisArg) {\n    var iterator = iterateSetValues(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  }; }\n});\n\nfunction finalizeTraps(traps) {\n  return Object.keys(traps).reduce(function (acc, key) {\n    var builder = key === \"size\" ? proxyAttr : proxyMethod;\n    acc[key] = builder(traps[key], key);\n    return acc;\n  }, {});\n}\n\nfunction proxyAttr(fn) {\n  return {\n    get: function get() {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      return fn(state);\n    }\n\n  };\n}\n\nfunction proxyMethod(trap, key) {\n  return {\n    get: function get() {\n      return function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        return trap(state, key, state.draft).apply(void 0, args);\n      };\n    }\n\n  };\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest$1(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (isMap(state.base)) {\n        if (hasMapChanges(state)) { markChanged(state); }\n      } else if (isSet(state.base)) {\n        if (hasSetChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) { assigned[i$1] = true; }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) { markChangesRecursively(draft[i$2]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction hasMapChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : value !== base.get(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction hasSetChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : !base.has(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize,\n\tcreateProxy: createProxy\n});\n\nvar obj$1, obj$1$1;\n\nfunction willFinalize$1() {}\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var target = state;\n  var traps = objectTraps;\n\n  if (Array.isArray(base)) {\n    target = [state];\n    traps = arrayTraps;\n  } // Map drafts must support object keys, so we use Map objects to track changes.\n  else if (isMap(base)) {\n      traps = mapTraps$1;\n      state.drafts = new Map();\n      state.assigned = new Map();\n    } // Set drafts use a Map object to track which of its values are drafted.\n    // And we don't need the \"assigned\" property, because Set objects have no keys.\n    else if (isSet(base)) {\n        traps = setTraps$1;\n        state.drafts = new Map();\n      }\n\n  var ref = Proxy.revocable(target, traps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n/**\n * Object drafts\n */\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) { return state; }\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest$2(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = createProxy$1(value, state);\n  },\n\n  has: function has(state, prop) {\n    return prop in latest$2(state);\n  },\n\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest$2(state));\n  },\n\n  set: function set(state, prop, value) {\n    if (!state.modified) {\n      var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n      if (isUnchanged) { return true; }\n      markChanged$1(state);\n    }\n\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n  },\n\n  deleteProperty: function deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      markChanged$1(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    }\n\n    if (state.copy) { delete state.copy[prop]; }\n    return true;\n  },\n\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest$2(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n    }\n\n    return desc;\n  },\n\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n\n  getPrototypeOf: function getPrototypeOf(state) {\n    return Object.getPrototypeOf(state.base);\n  },\n\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n\n};\n/**\n * Array drafts\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // Used by Map and Set drafts\n\n\nvar reflectTraps = makeReflectTraps([\"ownKeys\", \"has\", \"set\", \"deleteProperty\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"preventExtensions\", \"isExtensible\", \"getPrototypeOf\"]);\n/**\n * Map drafts\n */\n\nvar mapTraps$1 = makeTrapsForGetters(( obj$1 = {}, obj$1[DRAFT_STATE] = function (state) { return state; }, obj$1.size = function (state) { return latest$2(state).size; }, obj$1.has = function (state) { return function (key) { return latest$2(state).has(key); }; }, obj$1.set = function (state) { return function (key, value) {\n    var values = latest$2(state);\n\n    if (!values.has(key) || values.get(key) !== value) {\n      markChanged$1(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  }; }, obj$1.delete = function (state) { return function (key) {\n    if (latest$2(state).has(key)) {\n      markChanged$1(state);\n      state.assigned.set(key, false);\n      return state.copy.delete(key);\n    }\n\n    return false;\n  }; }, obj$1.clear = function (state) { return function () {\n    markChanged$1(state);\n    state.assigned = new Map();\n\n    for (var i = 0, list = latest$2(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  }; }, obj$1.forEach = function (state, _, receiver) { return function (cb, thisArg) { return latest$2(state).forEach(function (_, key, map) {\n    var value = receiver.get(key);\n    cb.call(thisArg, value, key, map);\n  }); }; }, obj$1.get = function (state) { return function (key) {\n    var drafts = state[state.modified ? \"copy\" : \"drafts\"];\n\n    if (drafts.has(key)) {\n      return drafts.get(key);\n    }\n\n    var value = latest$2(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    var draft = createProxy$1(value, state);\n    drafts.set(key, draft);\n    return draft;\n  }; }, obj$1.keys = function (state) { return function () { return latest$2(state).keys(); }; }, obj$1.values = iterateMapValues, obj$1.entries = iterateMapValues, obj$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateMapValues, obj$1 ));\nvar iterateSetValues$1 = makeIterateSetValues(createProxy$1);\n/**\n * Set drafts\n */\n\nvar setTraps$1 = makeTrapsForGetters(( obj$1$1 = {}, obj$1$1[DRAFT_STATE] = function (state) { return state; }, obj$1$1.size = function (state) { return latest$2(state).size; }, obj$1$1.has = function (state) { return function (key) { return latest$2(state).has(key); }; }, obj$1$1.add = function (state) { return function (value) {\n    if (!latest$2(state).has(value)) {\n      markChanged$1(state);\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  }; }, obj$1$1.delete = function (state) { return function (value) {\n    markChanged$1(state);\n    return state.copy.delete(value);\n  }; }, obj$1$1.clear = function (state) { return function () {\n    markChanged$1(state);\n    return state.copy.clear();\n  }; }, obj$1$1.forEach = function (state) { return function (cb, thisArg) {\n    var iterator = iterateSetValues$1(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  }; }, obj$1$1.keys = iterateSetValues$1, obj$1$1.values = iterateSetValues$1, obj$1$1.entries = iterateSetValues$1, obj$1$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateSetValues$1, obj$1$1 ));\n/**\n * Helpers\n */\n// Retrieve the latest values of the draft.\n\nfunction latest$2(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest$2(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    var base = state.base;\n    var drafts = state.drafts;\n    var parent = state.parent;\n    var copy = shallowCopy(base);\n\n    if (isSet(base)) {\n      // Note: The `drafts` property is preserved for Set objects, since\n      // we need to keep track of which values are drafted.\n      assignSet(copy, drafts);\n    } else {\n      // Merge nested drafts into the copy.\n      if (isMap(base)) { assignMap(copy, drafts); }else { assign(copy, drafts); }\n      state.drafts = null;\n    }\n\n    state.copy = copy;\n\n    if (parent) {\n      markChanged$1(parent);\n    }\n  }\n}\n/** Create traps that all use the `Reflect` API on the `latest(state)` */\n\n\nfunction makeReflectTraps(names) {\n  return names.reduce(function (traps, name) {\n    traps[name] = function (state) {\n      var args = [], len = arguments.length - 1;\n      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return Reflect[name].apply(Reflect, [ latest$2(state) ].concat( args ));\n    };\n\n    return traps;\n  }, {});\n}\n\nfunction makeTrapsForGetters(getters) {\n  return Object.assign({}, reflectTraps, {\n    get: function get(state, prop, receiver) {\n      return getters.hasOwnProperty(prop) ? getters[prop](state, prop, receiver) : Reflect.get(state, prop, receiver);\n    },\n\n    setPrototypeOf: function setPrototypeOf(state) {\n      throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n    }\n\n  });\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize$1,\n\tcreateProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  var generatePatchesFn = Array.isArray(state.base) ? generateArrayPatches : isSet(state.base) ? generateSetPatches : generatePatchesFromAssigned;\n  generatePatchesFn(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    (assign = [copy, base], base = assign[0], copy = assign[1]);\n    (assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1]);\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  var i = 0;\n\n  for (var i$1 = 0, list = base; i$1 < list.length; i$1 += 1) {\n    var value = list[i$1];\n\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  }\n\n  i = 0;\n\n  for (var i$2 = 0, list$1 = copy; i$2 < list$1.length; i$2 += 1) {\n    var value$1 = list$1[i$2];\n\n    if (!base.has(value$1)) {\n      var path$1 = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path$1,\n        value: value$1\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path$1,\n        value: value$1\n      });\n    }\n\n    i++;\n  }\n}\n\nvar applyPatches = function (draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n\n    var path = patch.path;\n    var op = patch.op;\n    if (!path.length) { throw new Error(\"Illegal state\"); }\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        if (isMap(base)) {\n          base.set(key, value);\n        } else if (isSet(base)) {\n          throw new Error('Sets cannot have \"replace\" patches.');\n        } else {\n          // if value is an object, then it's assigned by reference\n          // in the following add or remove ops, the value field inside the patch will also be modifyed\n          // so we use value from the cloned patch\n          base[key] = value;\n        }\n\n        break;\n\n      case \"add\":\n        if (isSet(base)) {\n          base.delete(patch.value);\n        }\n\n        Array.isArray(base) ? base.splice(key, 0, value) : isMap(base) ? base.set(key, value) : isSet(base) ? base.add(value) : base[key] = value;\n        break;\n\n      case \"remove\":\n        Array.isArray(base) ? base.splice(key, 1) : isMap(base) ? base.delete(key) : isSet(base) ? base.delete(patch.value) : delete base[key];\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n  this.produceWithPatches = this.produceWithPatches.bind(this);\n};\n\nImmer.prototype.produce = function produce (base, recipe, patchListener) {\n    var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n        var this$1 = this;\n        if ( base === void 0 ) base = defaultBase;\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return self.produce(base, function (draft) { return recipe.call.apply(recipe, [ this$1, draft ].concat( args )); }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) { scope.revoke(); }else { scope.leave(); }\n    }\n\n    if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === NOTHING) { return undefined; }\n    if (result === undefined) { result = base; }\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches (arg1, arg2, arg3) {\n    var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n        return this$1.produceWithPatches(state, function (draft) { return arg1.apply(void 0, [ draft ].concat( args )); });\n      };\n  } // non-curried form\n\n\n  if (arg3) { throw new Error(\"A patch listener cannot be passed to produceWithPatches\"); }\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft (base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft (draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze (value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies (value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1 (base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) { return applyPatches(draft, patches.slice(i + 1)); });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult (result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize (draft, path, scope) {\n    var this$1 = this;\n\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) { return draft; }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (this.onDelete && !isSet(state.base)) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) { this$1.onDelete(state, prop); }\n        });\n      } else {\n        // TODO: Figure it out for Maps and Sets if we need to support ES5\n        var base = state.base;\n          var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) { this$1.onDelete(state, prop); }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree (root, rootPath, scope) {\n    var this$1 = this;\n\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n    var isSetMember = isSet(parent);\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !isSetMember && // Set objects are atomic since they have no keys.\n      !has(state.assigned, prop) // Skip deep patches for assigned keys.\n      ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope);\n      replace(parent, prop, value); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === get(state.base, prop)) { return; }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, get(state.base, prop))) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n          this$1.maybeFreeze(value);\n        }\n\n    if (isDraftProp && this$1.onAssign && !isSetMember) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze (value, deep) {\n    if ( deep === void 0 ) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n};\n\nfunction replace(parent, prop, value) {\n  if (isMap(parent)) {\n    parent.set(prop, value);\n  } else if (isSet(parent)) {\n    // In this case, the `prop` is actually a draft.\n    parent.delete(prop);\n    parent.add(value);\n  } else if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n    // Preserve non-enumerable properties.\n    parent[prop] = value;\n  } else {\n    Object.defineProperty(parent, prop, {\n      value: value,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n"]},"metadata":{},"sourceType":"module"}