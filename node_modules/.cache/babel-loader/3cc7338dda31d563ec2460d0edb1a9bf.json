{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.combineReducers = combineReducers, exports.getDotStrPath = getDotStrPath, exports.getSlashStrPath = getSlashStrPath, exports.pathToArr = pathToArr, exports.preserveValuesFromState = preserveValuesFromState, exports.recursiveUnset = recursiveUnset;\nvar _unset2 = _interopRequireDefault(require(\"lodash/fp/unset\")),\n  _pick2 = _interopRequireDefault(require(\"lodash/pick\")),\n  _size2 = _interopRequireDefault(require(\"lodash/size\")),\n  _get2 = _interopRequireDefault(require(\"lodash/get\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\nfunction pathToArr(path) {\n  return path ? path.split(/\\//).filter(function (p) {\n    return !!p;\n  }) : [];\n}\nfunction getSlashStrPath(path) {\n  return pathToArr(path).join(\"/\");\n}\nfunction getDotStrPath(path) {\n  return pathToArr(path).join(\".\");\n}\nfunction combineReducers(reducers) {\n  return function () {\n    var state = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {},\n      action = 1 < arguments.length ? arguments[1] : void 0;\n    return Object.keys(reducers).reduce(function (nextState, key) {\n      return nextState[key] = reducers[key](state[key], action), nextState;\n    }, {});\n  };\n}\nfunction preserveValuesFromState(state, preserveSetting, nextState) {\n  if (\"function\" == typeof preserveSetting) return preserveSetting(state, nextState);\n  if (!0 === preserveSetting) return nextState ? _objectSpread(_objectSpread({}, state), nextState) : state;\n  if (Array.isArray(preserveSetting)) return (0, _pick2.default)(state, preserveSetting);\n  throw new Error(\"Invalid preserve parameter. It must be an Object or an Array\");\n}\nfunction recursiveUnset(path, obj) {\n  var isRecursiveCall = !!(2 < arguments.length && arguments[2] !== void 0) && arguments[2];\n  if (!path) return obj;\n  if (0 < (0, _size2.default)((0, _get2.default)(obj, path)) && isRecursiveCall) return obj;\n  var objectWithRemovedKey = (0, _unset2.default)(path, obj),\n    newPath = path.match(/\\./) ? path.replace(/\\.[^.]*$/, \"\") : \"\";\n  return recursiveUnset(newPath, objectWithRemovedKey, !0);\n}","map":{"version":3,"sources":["../../src/utils/reducers.js"],"names":["pathToArr","path","split","filter","p","getSlashStrPath","join","getDotStrPath","combineReducers","reducers","state","action","Object","keys","reduce","nextState","key","preserveValuesFromState","preserveSetting","Array","isArray","Error","recursiveUnset","obj","isRecursiveCall","objectWithRemovedKey","newPath","match","replace"],"mappings":"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","sourcesContent":["import { get, size, pick } from 'lodash'\nimport { unset } from 'lodash/fp'\n\n/**\n * Create a path array from path string\n * @param {string} path - Path seperated with slashes\n * @returns {Array} Path as Array\n * @private\n */\nexport function pathToArr(path) {\n  return path ? path.split(/\\//).filter((p) => !!p) : []\n}\n\n/**\n * Trim leading slash from path for use with state\n * @param {string} path - Path seperated with slashes\n * @returns {string} Path seperated with slashes\n * @private\n */\nexport function getSlashStrPath(path) {\n  return pathToArr(path).join('/')\n}\n\n/**\n * Convert path with slashes to dot seperated path (for use with lodash get/set)\n * @param {string} path - Path seperated with slashes\n * @returns {string} Path seperated with dots\n * @private\n */\nexport function getDotStrPath(path) {\n  return pathToArr(path).join('.')\n}\n\n/**\n * Combine reducers utility (abreveated version of redux's combineReducer).\n * Turns an object whose values are different reducer functions, into a single\n * reducer function.\n * @param {object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one.\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n * @private\n */\nexport function combineReducers(reducers) {\n  return (state = {}, action) => {\n    return Object.keys(reducers).reduce((nextState, key) => {\n      nextState[key] = reducers[key](\n        // eslint-disable-line no-param-reassign\n        state[key],\n        action\n      )\n      return nextState\n    }, {})\n  }\n}\n\n/**\n * Preserve values from redux state change\n * @param {object} state - Redux state\n * @param {Function|boolean|Array} preserveSetting - Setting for which values to preserve\n * from redux state\n * @param {object} nextState - Next redux state\n * @returns {object} State with values preserved\n */\nexport function preserveValuesFromState(state, preserveSetting, nextState) {\n  // Return result of function if preserve is a function\n  if (typeof preserveSetting === 'function') {\n    return preserveSetting(state, nextState)\n  }\n\n  // Return original state if preserve is true\n  if (preserveSetting === true) {\n    return nextState ? { ...state, ...nextState } : state\n  }\n\n  if (Array.isArray(preserveSetting)) {\n    return pick(state, preserveSetting) // pick returns a new object\n  }\n\n  throw new Error(\n    'Invalid preserve parameter. It must be an Object or an Array'\n  )\n}\n\n/**\n * Recursively unset a property starting at the deep path, and unsetting the parent\n * property if there are no other enumerable properties at that level.\n * @param {string} path - Deep dot path of the property to unset\n * @param {object} obj - Object from which path should be recursivley unset\n * @param {boolean} [isRecursiveCall=false] - Used internally to ensure that\n * the object size check is only performed after one iteration.\n * @returns {object} The object with the property deeply unset\n * @private\n */\nexport function recursiveUnset(path, obj, isRecursiveCall = false) {\n  if (!path) {\n    return obj\n  }\n\n  if (size(get(obj, path)) > 0 && isRecursiveCall) {\n    return obj\n  }\n  // The object does not have any other properties at this level.  Remove the\n  // property.\n  const objectWithRemovedKey = unset(path, obj)\n  const newPath = path.match(/\\./) ? path.replace(/\\.[^.]*$/, '') : ''\n  return recursiveUnset(newPath, objectWithRemovedKey, true)\n}\n"]},"metadata":{},"sourceType":"script"}