{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.default = void 0, exports.getEventsFromInput = getEventsFromInput, exports.pathStrToObj = pathStrToObj;\nvar _remove2 = _interopRequireDefault(require(\"lodash/remove\")),\n  _isObject2 = _interopRequireDefault(require(\"lodash/isObject\")),\n  _flatMap2 = _interopRequireDefault(require(\"lodash/flatMap\")),\n  _populate = require(\"./populate\"),\n  _query = require(\"./query\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction pathStrToObj(path) {\n  var pathObj = {\n      path: path,\n      type: \"value\",\n      isQuery: !1\n    },\n    queryId = (0, _query.getQueryIdFromPath)(path);\n  if (queryId) {\n    var pathArray = path.split(\"#\");\n    pathObj = Object.assign({}, pathObj, {\n      queryId: queryId,\n      isQuery: !0,\n      path: pathArray[0],\n      queryParams: pathArray[1].split(\"&\")\n    }), (0, _populate.getPopulates)(pathArray[1].split(\"&\")) && (pathObj.populates = (0, _populate.getPopulates)(pathArray[1].split(\"&\")), pathObj.queryParams = (0, _remove2.default)(pathArray[1].split(\"&\"), function (p) {\n      return -1 === p.indexOf(\"populate\");\n    }));\n  }\n  return pathObj;\n}\nfunction getEventsFromInput(paths) {\n  return (0, _flatMap2.default)(paths, function (path) {\n    if (\"string\" == typeof path || path instanceof String) return [pathStrToObj(path)];\n    if (Array.isArray(path)) return [{\n      type: \"first_child\",\n      path: path[0]\n    }, {\n      type: \"child_added\",\n      path: path[0]\n    }, {\n      type: \"child_removed\",\n      path: path[0]\n    }, {\n      type: \"child_moved\",\n      path: path[0]\n    }, {\n      type: \"child_changed\",\n      path: path[0]\n    }];\n    if ((0, _isObject2.default)(path)) {\n      if (!path.path) throw new Error(\"Path is a required parameter within definition object\");\n      var strPath = path.path;\n      return path.storeAs && (strPath += \"@\".concat(path.storeAs)), path.queryParams && (strPath += \"#\".concat(path.queryParams.join(\"&\"))), path = Object.assign({}, pathStrToObj(strPath), path), [path];\n    }\n    throw new Error(\"Invalid Path Definition: \".concat(path, \". Only strings, objects, and arrays accepted.\"));\n  });\n}\nvar _default = {\n  getEventsFromInput: getEventsFromInput\n};\nexports.default = _default;","map":{"version":3,"sources":["../../src/utils/events.js"],"names":["pathStrToObj","path","pathObj","type","isQuery","queryId","pathArray","split","Object","assign","queryParams","populates","p","indexOf","getEventsFromInput","paths","String","Array","isArray","Error","strPath","storeAs","join"],"mappings":"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","sourcesContent":["import { flatMap, isObject, remove } from 'lodash'\nimport { getPopulates } from './populate'\nimport { getQueryIdFromPath } from './query'\n\n/**\n * @description Convert path string to object with queryParams, path, and populates\n * @param {string} path - Path that can contain query parameters and populates\n * @returns {object} watchEvents - Array of watch events\n */\nexport function pathStrToObj(path) {\n  let pathObj = { path, type: 'value', isQuery: false }\n  const queryId = getQueryIdFromPath(path)\n  // If Query id exists split params from path\n  if (queryId) {\n    const pathArray = path.split('#')\n    pathObj = Object.assign({}, pathObj, {\n      queryId,\n      isQuery: true,\n      path: pathArray[0],\n      queryParams: pathArray[1].split('&')\n    })\n    if (getPopulates(pathArray[1].split('&'))) {\n      pathObj.populates = getPopulates(pathArray[1].split('&'))\n      pathObj.queryParams = remove(\n        pathArray[1].split('&'),\n        (p) => p.indexOf('populate') === -1\n      )\n    }\n  }\n  // if queryId does not exist, return original pathObj\n  return pathObj\n}\n\n/**\n * @description Convert watch path definition array to watch events\n * @param {Array} paths - Array of path strings, objects, and arrays to watch\n * @returns {Array} watchEvents - Array of watch events\n */\nexport function getEventsFromInput(paths) {\n  return flatMap(paths, (path) => {\n    // If path is a string - convert to obj and place within new array\n    if (typeof path === 'string' || path instanceof String) {\n      return [pathStrToObj(path)]\n    }\n\n    if (Array.isArray(path)) {\n      // TODO: Handle input other than array with string\n      // TODO: Handle populates within array\n      return [\n        { type: 'first_child', path: path[0] },\n        { type: 'child_added', path: path[0] },\n        { type: 'child_removed', path: path[0] },\n        { type: 'child_moved', path: path[0] },\n        { type: 'child_changed', path: path[0] }\n      ]\n    }\n\n    if (isObject(path)) {\n      if (!path.path) {\n        throw new Error('Path is a required parameter within definition object')\n      }\n      let strPath = path.path\n\n      if (path.storeAs) {\n        // append storeAs to query path\n        strPath += `@${path.storeAs}`\n      }\n\n      if (path.queryParams) {\n        // append query params to path for queryId added in pathStrToObj\n        strPath += `#${path.queryParams.join('&')}`\n      }\n\n      // Add all parameters that are missing (ones that exist will remain)\n      path = Object.assign({}, pathStrToObj(strPath), path)\n      return [path]\n    }\n\n    throw new Error(\n      `Invalid Path Definition: ${path}. Only strings, objects, and arrays accepted.`\n    )\n  })\n}\n\nexport default { getEventsFromInput }\n"]},"metadata":{},"sourceType":"script"}